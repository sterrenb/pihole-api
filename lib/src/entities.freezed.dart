// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'entities.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PiholeRepositoryParamsTearOff {
  const _$PiholeRepositoryParamsTearOff();

  _PiholeRepositoryParams call(
      {required Dio dio,
      required String baseUrl,
      required bool useSsl,
      required String apiPath,
      required int apiPort,
      required bool apiTokenRequired,
      required String apiToken,
      required bool allowSelfSignedCertificates,
      required String adminHome}) {
    return _PiholeRepositoryParams(
      dio: dio,
      baseUrl: baseUrl,
      useSsl: useSsl,
      apiPath: apiPath,
      apiPort: apiPort,
      apiTokenRequired: apiTokenRequired,
      apiToken: apiToken,
      allowSelfSignedCertificates: allowSelfSignedCertificates,
      adminHome: adminHome,
    );
  }
}

/// @nodoc
const $PiholeRepositoryParams = _$PiholeRepositoryParamsTearOff();

/// @nodoc
mixin _$PiholeRepositoryParams {
  Dio get dio => throw _privateConstructorUsedError;
  String get baseUrl => throw _privateConstructorUsedError;
  bool get useSsl => throw _privateConstructorUsedError;
  String get apiPath => throw _privateConstructorUsedError;
  int get apiPort => throw _privateConstructorUsedError;
  bool get apiTokenRequired => throw _privateConstructorUsedError;
  String get apiToken => throw _privateConstructorUsedError;
  bool get allowSelfSignedCertificates => throw _privateConstructorUsedError;
  String get adminHome => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiholeRepositoryParamsCopyWith<PiholeRepositoryParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiholeRepositoryParamsCopyWith<$Res> {
  factory $PiholeRepositoryParamsCopyWith(PiholeRepositoryParams value,
          $Res Function(PiholeRepositoryParams) then) =
      _$PiholeRepositoryParamsCopyWithImpl<$Res>;
  $Res call(
      {Dio dio,
      String baseUrl,
      bool useSsl,
      String apiPath,
      int apiPort,
      bool apiTokenRequired,
      String apiToken,
      bool allowSelfSignedCertificates,
      String adminHome});
}

/// @nodoc
class _$PiholeRepositoryParamsCopyWithImpl<$Res>
    implements $PiholeRepositoryParamsCopyWith<$Res> {
  _$PiholeRepositoryParamsCopyWithImpl(this._value, this._then);

  final PiholeRepositoryParams _value;
  // ignore: unused_field
  final $Res Function(PiholeRepositoryParams) _then;

  @override
  $Res call({
    Object? dio = freezed,
    Object? baseUrl = freezed,
    Object? useSsl = freezed,
    Object? apiPath = freezed,
    Object? apiPort = freezed,
    Object? apiTokenRequired = freezed,
    Object? apiToken = freezed,
    Object? allowSelfSignedCertificates = freezed,
    Object? adminHome = freezed,
  }) {
    return _then(_value.copyWith(
      dio: dio == freezed
          ? _value.dio
          : dio // ignore: cast_nullable_to_non_nullable
              as Dio,
      baseUrl: baseUrl == freezed
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      useSsl: useSsl == freezed
          ? _value.useSsl
          : useSsl // ignore: cast_nullable_to_non_nullable
              as bool,
      apiPath: apiPath == freezed
          ? _value.apiPath
          : apiPath // ignore: cast_nullable_to_non_nullable
              as String,
      apiPort: apiPort == freezed
          ? _value.apiPort
          : apiPort // ignore: cast_nullable_to_non_nullable
              as int,
      apiTokenRequired: apiTokenRequired == freezed
          ? _value.apiTokenRequired
          : apiTokenRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      apiToken: apiToken == freezed
          ? _value.apiToken
          : apiToken // ignore: cast_nullable_to_non_nullable
              as String,
      allowSelfSignedCertificates: allowSelfSignedCertificates == freezed
          ? _value.allowSelfSignedCertificates
          : allowSelfSignedCertificates // ignore: cast_nullable_to_non_nullable
              as bool,
      adminHome: adminHome == freezed
          ? _value.adminHome
          : adminHome // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$PiholeRepositoryParamsCopyWith<$Res>
    implements $PiholeRepositoryParamsCopyWith<$Res> {
  factory _$PiholeRepositoryParamsCopyWith(_PiholeRepositoryParams value,
          $Res Function(_PiholeRepositoryParams) then) =
      __$PiholeRepositoryParamsCopyWithImpl<$Res>;
  @override
  $Res call(
      {Dio dio,
      String baseUrl,
      bool useSsl,
      String apiPath,
      int apiPort,
      bool apiTokenRequired,
      String apiToken,
      bool allowSelfSignedCertificates,
      String adminHome});
}

/// @nodoc
class __$PiholeRepositoryParamsCopyWithImpl<$Res>
    extends _$PiholeRepositoryParamsCopyWithImpl<$Res>
    implements _$PiholeRepositoryParamsCopyWith<$Res> {
  __$PiholeRepositoryParamsCopyWithImpl(_PiholeRepositoryParams _value,
      $Res Function(_PiholeRepositoryParams) _then)
      : super(_value, (v) => _then(v as _PiholeRepositoryParams));

  @override
  _PiholeRepositoryParams get _value => super._value as _PiholeRepositoryParams;

  @override
  $Res call({
    Object? dio = freezed,
    Object? baseUrl = freezed,
    Object? useSsl = freezed,
    Object? apiPath = freezed,
    Object? apiPort = freezed,
    Object? apiTokenRequired = freezed,
    Object? apiToken = freezed,
    Object? allowSelfSignedCertificates = freezed,
    Object? adminHome = freezed,
  }) {
    return _then(_PiholeRepositoryParams(
      dio: dio == freezed
          ? _value.dio
          : dio // ignore: cast_nullable_to_non_nullable
              as Dio,
      baseUrl: baseUrl == freezed
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      useSsl: useSsl == freezed
          ? _value.useSsl
          : useSsl // ignore: cast_nullable_to_non_nullable
              as bool,
      apiPath: apiPath == freezed
          ? _value.apiPath
          : apiPath // ignore: cast_nullable_to_non_nullable
              as String,
      apiPort: apiPort == freezed
          ? _value.apiPort
          : apiPort // ignore: cast_nullable_to_non_nullable
              as int,
      apiTokenRequired: apiTokenRequired == freezed
          ? _value.apiTokenRequired
          : apiTokenRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      apiToken: apiToken == freezed
          ? _value.apiToken
          : apiToken // ignore: cast_nullable_to_non_nullable
              as String,
      allowSelfSignedCertificates: allowSelfSignedCertificates == freezed
          ? _value.allowSelfSignedCertificates
          : allowSelfSignedCertificates // ignore: cast_nullable_to_non_nullable
              as bool,
      adminHome: adminHome == freezed
          ? _value.adminHome
          : adminHome // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_PiholeRepositoryParams extends _PiholeRepositoryParams {
  _$_PiholeRepositoryParams(
      {required this.dio,
      required this.baseUrl,
      required this.useSsl,
      required this.apiPath,
      required this.apiPort,
      required this.apiTokenRequired,
      required this.apiToken,
      required this.allowSelfSignedCertificates,
      required this.adminHome})
      : super._();

  @override
  final Dio dio;
  @override
  final String baseUrl;
  @override
  final bool useSsl;
  @override
  final String apiPath;
  @override
  final int apiPort;
  @override
  final bool apiTokenRequired;
  @override
  final String apiToken;
  @override
  final bool allowSelfSignedCertificates;
  @override
  final String adminHome;

  @override
  String toString() {
    return 'PiholeRepositoryParams(dio: $dio, baseUrl: $baseUrl, useSsl: $useSsl, apiPath: $apiPath, apiPort: $apiPort, apiTokenRequired: $apiTokenRequired, apiToken: $apiToken, allowSelfSignedCertificates: $allowSelfSignedCertificates, adminHome: $adminHome)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiholeRepositoryParams &&
            (identical(other.dio, dio) || other.dio == dio) &&
            (identical(other.baseUrl, baseUrl) || other.baseUrl == baseUrl) &&
            (identical(other.useSsl, useSsl) || other.useSsl == useSsl) &&
            (identical(other.apiPath, apiPath) || other.apiPath == apiPath) &&
            (identical(other.apiPort, apiPort) || other.apiPort == apiPort) &&
            (identical(other.apiTokenRequired, apiTokenRequired) ||
                other.apiTokenRequired == apiTokenRequired) &&
            (identical(other.apiToken, apiToken) ||
                other.apiToken == apiToken) &&
            (identical(other.allowSelfSignedCertificates,
                    allowSelfSignedCertificates) ||
                other.allowSelfSignedCertificates ==
                    allowSelfSignedCertificates) &&
            (identical(other.adminHome, adminHome) ||
                other.adminHome == adminHome));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      dio,
      baseUrl,
      useSsl,
      apiPath,
      apiPort,
      apiTokenRequired,
      apiToken,
      allowSelfSignedCertificates,
      adminHome);

  @JsonKey(ignore: true)
  @override
  _$PiholeRepositoryParamsCopyWith<_PiholeRepositoryParams> get copyWith =>
      __$PiholeRepositoryParamsCopyWithImpl<_PiholeRepositoryParams>(
          this, _$identity);
}

abstract class _PiholeRepositoryParams extends PiholeRepositoryParams {
  factory _PiholeRepositoryParams(
      {required Dio dio,
      required String baseUrl,
      required bool useSsl,
      required String apiPath,
      required int apiPort,
      required bool apiTokenRequired,
      required String apiToken,
      required bool allowSelfSignedCertificates,
      required String adminHome}) = _$_PiholeRepositoryParams;
  _PiholeRepositoryParams._() : super._();

  @override
  Dio get dio;
  @override
  String get baseUrl;
  @override
  bool get useSsl;
  @override
  String get apiPath;
  @override
  int get apiPort;
  @override
  bool get apiTokenRequired;
  @override
  String get apiToken;
  @override
  bool get allowSelfSignedCertificates;
  @override
  String get adminHome;
  @override
  @JsonKey(ignore: true)
  _$PiholeRepositoryParamsCopyWith<_PiholeRepositoryParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiholeApiFailureTearOff {
  const _$PiholeApiFailureTearOff();

  _NotFound notFound() {
    return _NotFound();
  }

  _NotAuthenticated notAuthenticated() {
    return const _NotAuthenticated();
  }

  _InvalidResponse invalidResponse(int statusCode) {
    return _InvalidResponse(
      statusCode,
    );
  }

  _EmptyString emptyString() {
    return const _EmptyString();
  }

  _EmptyList emptyList() {
    return const _EmptyList();
  }

  _Cancelled cancelled() {
    return const _Cancelled();
  }

  _Timeout timeout() {
    return const _Timeout();
  }

  _HostName hostname() {
    return const _HostName();
  }

  _GeneralApiFailure general(String message) {
    return _GeneralApiFailure(
      message,
    );
  }

  _UnknownApiFailure unknown(dynamic e) {
    return _UnknownApiFailure(
      e,
    );
  }
}

/// @nodoc
const $PiholeApiFailure = _$PiholeApiFailureTearOff();

/// @nodoc
mixin _$PiholeApiFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiholeApiFailureCopyWith<$Res> {
  factory $PiholeApiFailureCopyWith(
          PiholeApiFailure value, $Res Function(PiholeApiFailure) then) =
      _$PiholeApiFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$PiholeApiFailureCopyWithImpl<$Res>
    implements $PiholeApiFailureCopyWith<$Res> {
  _$PiholeApiFailureCopyWithImpl(this._value, this._then);

  final PiholeApiFailure _value;
  // ignore: unused_field
  final $Res Function(PiholeApiFailure) _then;
}

/// @nodoc
abstract class _$NotFoundCopyWith<$Res> {
  factory _$NotFoundCopyWith(_NotFound value, $Res Function(_NotFound) then) =
      __$NotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$NotFoundCopyWithImpl<$Res> extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$NotFoundCopyWith<$Res> {
  __$NotFoundCopyWithImpl(_NotFound _value, $Res Function(_NotFound) _then)
      : super(_value, (v) => _then(v as _NotFound));

  @override
  _NotFound get _value => super._value as _NotFound;
}

/// @nodoc

class _$_NotFound implements _NotFound {
  _$_NotFound();

  @override
  String toString() {
    return 'PiholeApiFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _NotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class _NotFound implements PiholeApiFailure {
  factory _NotFound() = _$_NotFound;
}

/// @nodoc
abstract class _$NotAuthenticatedCopyWith<$Res> {
  factory _$NotAuthenticatedCopyWith(
          _NotAuthenticated value, $Res Function(_NotAuthenticated) then) =
      __$NotAuthenticatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$NotAuthenticatedCopyWithImpl<$Res>
    extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$NotAuthenticatedCopyWith<$Res> {
  __$NotAuthenticatedCopyWithImpl(
      _NotAuthenticated _value, $Res Function(_NotAuthenticated) _then)
      : super(_value, (v) => _then(v as _NotAuthenticated));

  @override
  _NotAuthenticated get _value => super._value as _NotAuthenticated;
}

/// @nodoc

class _$_NotAuthenticated implements _NotAuthenticated {
  const _$_NotAuthenticated();

  @override
  String toString() {
    return 'PiholeApiFailure.notAuthenticated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _NotAuthenticated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return notAuthenticated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return notAuthenticated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (notAuthenticated != null) {
      return notAuthenticated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return notAuthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return notAuthenticated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (notAuthenticated != null) {
      return notAuthenticated(this);
    }
    return orElse();
  }
}

abstract class _NotAuthenticated implements PiholeApiFailure {
  const factory _NotAuthenticated() = _$_NotAuthenticated;
}

/// @nodoc
abstract class _$InvalidResponseCopyWith<$Res> {
  factory _$InvalidResponseCopyWith(
          _InvalidResponse value, $Res Function(_InvalidResponse) then) =
      __$InvalidResponseCopyWithImpl<$Res>;
  $Res call({int statusCode});
}

/// @nodoc
class __$InvalidResponseCopyWithImpl<$Res>
    extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$InvalidResponseCopyWith<$Res> {
  __$InvalidResponseCopyWithImpl(
      _InvalidResponse _value, $Res Function(_InvalidResponse) _then)
      : super(_value, (v) => _then(v as _InvalidResponse));

  @override
  _InvalidResponse get _value => super._value as _InvalidResponse;

  @override
  $Res call({
    Object? statusCode = freezed,
  }) {
    return _then(_InvalidResponse(
      statusCode == freezed
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_InvalidResponse implements _InvalidResponse {
  const _$_InvalidResponse(this.statusCode);

  @override
  final int statusCode;

  @override
  String toString() {
    return 'PiholeApiFailure.invalidResponse(statusCode: $statusCode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _InvalidResponse &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, statusCode);

  @JsonKey(ignore: true)
  @override
  _$InvalidResponseCopyWith<_InvalidResponse> get copyWith =>
      __$InvalidResponseCopyWithImpl<_InvalidResponse>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return invalidResponse(statusCode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return invalidResponse?.call(statusCode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (invalidResponse != null) {
      return invalidResponse(statusCode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return invalidResponse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return invalidResponse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (invalidResponse != null) {
      return invalidResponse(this);
    }
    return orElse();
  }
}

abstract class _InvalidResponse implements PiholeApiFailure {
  const factory _InvalidResponse(int statusCode) = _$_InvalidResponse;

  int get statusCode;
  @JsonKey(ignore: true)
  _$InvalidResponseCopyWith<_InvalidResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$EmptyStringCopyWith<$Res> {
  factory _$EmptyStringCopyWith(
          _EmptyString value, $Res Function(_EmptyString) then) =
      __$EmptyStringCopyWithImpl<$Res>;
}

/// @nodoc
class __$EmptyStringCopyWithImpl<$Res>
    extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$EmptyStringCopyWith<$Res> {
  __$EmptyStringCopyWithImpl(
      _EmptyString _value, $Res Function(_EmptyString) _then)
      : super(_value, (v) => _then(v as _EmptyString));

  @override
  _EmptyString get _value => super._value as _EmptyString;
}

/// @nodoc

class _$_EmptyString implements _EmptyString {
  const _$_EmptyString();

  @override
  String toString() {
    return 'PiholeApiFailure.emptyString()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _EmptyString);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return emptyString();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return emptyString?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (emptyString != null) {
      return emptyString();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return emptyString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return emptyString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (emptyString != null) {
      return emptyString(this);
    }
    return orElse();
  }
}

abstract class _EmptyString implements PiholeApiFailure {
  const factory _EmptyString() = _$_EmptyString;
}

/// @nodoc
abstract class _$EmptyListCopyWith<$Res> {
  factory _$EmptyListCopyWith(
          _EmptyList value, $Res Function(_EmptyList) then) =
      __$EmptyListCopyWithImpl<$Res>;
}

/// @nodoc
class __$EmptyListCopyWithImpl<$Res>
    extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$EmptyListCopyWith<$Res> {
  __$EmptyListCopyWithImpl(_EmptyList _value, $Res Function(_EmptyList) _then)
      : super(_value, (v) => _then(v as _EmptyList));

  @override
  _EmptyList get _value => super._value as _EmptyList;
}

/// @nodoc

class _$_EmptyList implements _EmptyList {
  const _$_EmptyList();

  @override
  String toString() {
    return 'PiholeApiFailure.emptyList()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _EmptyList);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return emptyList();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return emptyList?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (emptyList != null) {
      return emptyList();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return emptyList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return emptyList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (emptyList != null) {
      return emptyList(this);
    }
    return orElse();
  }
}

abstract class _EmptyList implements PiholeApiFailure {
  const factory _EmptyList() = _$_EmptyList;
}

/// @nodoc
abstract class _$CancelledCopyWith<$Res> {
  factory _$CancelledCopyWith(
          _Cancelled value, $Res Function(_Cancelled) then) =
      __$CancelledCopyWithImpl<$Res>;
}

/// @nodoc
class __$CancelledCopyWithImpl<$Res>
    extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$CancelledCopyWith<$Res> {
  __$CancelledCopyWithImpl(_Cancelled _value, $Res Function(_Cancelled) _then)
      : super(_value, (v) => _then(v as _Cancelled));

  @override
  _Cancelled get _value => super._value as _Cancelled;
}

/// @nodoc

class _$_Cancelled implements _Cancelled {
  const _$_Cancelled();

  @override
  String toString() {
    return 'PiholeApiFailure.cancelled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Cancelled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return cancelled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return cancelled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class _Cancelled implements PiholeApiFailure {
  const factory _Cancelled() = _$_Cancelled;
}

/// @nodoc
abstract class _$TimeoutCopyWith<$Res> {
  factory _$TimeoutCopyWith(_Timeout value, $Res Function(_Timeout) then) =
      __$TimeoutCopyWithImpl<$Res>;
}

/// @nodoc
class __$TimeoutCopyWithImpl<$Res> extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$TimeoutCopyWith<$Res> {
  __$TimeoutCopyWithImpl(_Timeout _value, $Res Function(_Timeout) _then)
      : super(_value, (v) => _then(v as _Timeout));

  @override
  _Timeout get _value => super._value as _Timeout;
}

/// @nodoc

class _$_Timeout implements _Timeout {
  const _$_Timeout();

  @override
  String toString() {
    return 'PiholeApiFailure.timeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Timeout);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return timeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return timeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return timeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout(this);
    }
    return orElse();
  }
}

abstract class _Timeout implements PiholeApiFailure {
  const factory _Timeout() = _$_Timeout;
}

/// @nodoc
abstract class _$HostNameCopyWith<$Res> {
  factory _$HostNameCopyWith(_HostName value, $Res Function(_HostName) then) =
      __$HostNameCopyWithImpl<$Res>;
}

/// @nodoc
class __$HostNameCopyWithImpl<$Res> extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$HostNameCopyWith<$Res> {
  __$HostNameCopyWithImpl(_HostName _value, $Res Function(_HostName) _then)
      : super(_value, (v) => _then(v as _HostName));

  @override
  _HostName get _value => super._value as _HostName;
}

/// @nodoc

class _$_HostName implements _HostName {
  const _$_HostName();

  @override
  String toString() {
    return 'PiholeApiFailure.hostname()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _HostName);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return hostname();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return hostname?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (hostname != null) {
      return hostname();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return hostname(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return hostname?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (hostname != null) {
      return hostname(this);
    }
    return orElse();
  }
}

abstract class _HostName implements PiholeApiFailure {
  const factory _HostName() = _$_HostName;
}

/// @nodoc
abstract class _$GeneralApiFailureCopyWith<$Res> {
  factory _$GeneralApiFailureCopyWith(
          _GeneralApiFailure value, $Res Function(_GeneralApiFailure) then) =
      __$GeneralApiFailureCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class __$GeneralApiFailureCopyWithImpl<$Res>
    extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$GeneralApiFailureCopyWith<$Res> {
  __$GeneralApiFailureCopyWithImpl(
      _GeneralApiFailure _value, $Res Function(_GeneralApiFailure) _then)
      : super(_value, (v) => _then(v as _GeneralApiFailure));

  @override
  _GeneralApiFailure get _value => super._value as _GeneralApiFailure;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_GeneralApiFailure(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_GeneralApiFailure implements _GeneralApiFailure {
  const _$_GeneralApiFailure(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'PiholeApiFailure.general(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _GeneralApiFailure &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  _$GeneralApiFailureCopyWith<_GeneralApiFailure> get copyWith =>
      __$GeneralApiFailureCopyWithImpl<_GeneralApiFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return general(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return general?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (general != null) {
      return general(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return general(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return general?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (general != null) {
      return general(this);
    }
    return orElse();
  }
}

abstract class _GeneralApiFailure implements PiholeApiFailure {
  const factory _GeneralApiFailure(String message) = _$_GeneralApiFailure;

  String get message;
  @JsonKey(ignore: true)
  _$GeneralApiFailureCopyWith<_GeneralApiFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UnknownApiFailureCopyWith<$Res> {
  factory _$UnknownApiFailureCopyWith(
          _UnknownApiFailure value, $Res Function(_UnknownApiFailure) then) =
      __$UnknownApiFailureCopyWithImpl<$Res>;
  $Res call({dynamic e});
}

/// @nodoc
class __$UnknownApiFailureCopyWithImpl<$Res>
    extends _$PiholeApiFailureCopyWithImpl<$Res>
    implements _$UnknownApiFailureCopyWith<$Res> {
  __$UnknownApiFailureCopyWithImpl(
      _UnknownApiFailure _value, $Res Function(_UnknownApiFailure) _then)
      : super(_value, (v) => _then(v as _UnknownApiFailure));

  @override
  _UnknownApiFailure get _value => super._value as _UnknownApiFailure;

  @override
  $Res call({
    Object? e = freezed,
  }) {
    return _then(_UnknownApiFailure(
      e == freezed
          ? _value.e
          : e // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$_UnknownApiFailure implements _UnknownApiFailure {
  const _$_UnknownApiFailure(this.e);

  @override
  final dynamic e;

  @override
  String toString() {
    return 'PiholeApiFailure.unknown(e: $e)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UnknownApiFailure &&
            const DeepCollectionEquality().equals(other.e, e));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(e));

  @JsonKey(ignore: true)
  @override
  _$UnknownApiFailureCopyWith<_UnknownApiFailure> get copyWith =>
      __$UnknownApiFailureCopyWithImpl<_UnknownApiFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() notAuthenticated,
    required TResult Function(int statusCode) invalidResponse,
    required TResult Function() emptyString,
    required TResult Function() emptyList,
    required TResult Function() cancelled,
    required TResult Function() timeout,
    required TResult Function() hostname,
    required TResult Function(String message) general,
    required TResult Function(dynamic e) unknown,
  }) {
    return unknown(e);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
  }) {
    return unknown?.call(e);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? notAuthenticated,
    TResult Function(int statusCode)? invalidResponse,
    TResult Function()? emptyString,
    TResult Function()? emptyList,
    TResult Function()? cancelled,
    TResult Function()? timeout,
    TResult Function()? hostname,
    TResult Function(String message)? general,
    TResult Function(dynamic e)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(e);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NotFound value) notFound,
    required TResult Function(_NotAuthenticated value) notAuthenticated,
    required TResult Function(_InvalidResponse value) invalidResponse,
    required TResult Function(_EmptyString value) emptyString,
    required TResult Function(_EmptyList value) emptyList,
    required TResult Function(_Cancelled value) cancelled,
    required TResult Function(_Timeout value) timeout,
    required TResult Function(_HostName value) hostname,
    required TResult Function(_GeneralApiFailure value) general,
    required TResult Function(_UnknownApiFailure value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NotFound value)? notFound,
    TResult Function(_NotAuthenticated value)? notAuthenticated,
    TResult Function(_InvalidResponse value)? invalidResponse,
    TResult Function(_EmptyString value)? emptyString,
    TResult Function(_EmptyList value)? emptyList,
    TResult Function(_Cancelled value)? cancelled,
    TResult Function(_Timeout value)? timeout,
    TResult Function(_HostName value)? hostname,
    TResult Function(_GeneralApiFailure value)? general,
    TResult Function(_UnknownApiFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _UnknownApiFailure implements PiholeApiFailure {
  const factory _UnknownApiFailure(dynamic e) = _$_UnknownApiFailure;

  dynamic get e;
  @JsonKey(ignore: true)
  _$UnknownApiFailureCopyWith<_UnknownApiFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiholeStatusTearOff {
  const _$PiholeStatusTearOff();

  PiholeStatusLoading loading() {
    return const PiholeStatusLoading();
  }

  PiholeStatusEnabled enabled() {
    return const PiholeStatusEnabled();
  }

  PiholeStatusDisabled disabled() {
    return const PiholeStatusDisabled();
  }

  PiholeStatusSleeping sleeping(Duration duration, DateTime start) {
    return PiholeStatusSleeping(
      duration,
      start,
    );
  }

  PiholeStatusFailure failure(PiholeApiFailure failure) {
    return PiholeStatusFailure(
      failure,
    );
  }
}

/// @nodoc
const $PiholeStatus = _$PiholeStatusTearOff();

/// @nodoc
mixin _$PiholeStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() enabled,
    required TResult Function() disabled,
    required TResult Function(Duration duration, DateTime start) sleeping,
    required TResult Function(PiholeApiFailure failure) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PiholeStatusLoading value) loading,
    required TResult Function(PiholeStatusEnabled value) enabled,
    required TResult Function(PiholeStatusDisabled value) disabled,
    required TResult Function(PiholeStatusSleeping value) sleeping,
    required TResult Function(PiholeStatusFailure value) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiholeStatusCopyWith<$Res> {
  factory $PiholeStatusCopyWith(
          PiholeStatus value, $Res Function(PiholeStatus) then) =
      _$PiholeStatusCopyWithImpl<$Res>;
}

/// @nodoc
class _$PiholeStatusCopyWithImpl<$Res> implements $PiholeStatusCopyWith<$Res> {
  _$PiholeStatusCopyWithImpl(this._value, this._then);

  final PiholeStatus _value;
  // ignore: unused_field
  final $Res Function(PiholeStatus) _then;
}

/// @nodoc
abstract class $PiholeStatusLoadingCopyWith<$Res> {
  factory $PiholeStatusLoadingCopyWith(
          PiholeStatusLoading value, $Res Function(PiholeStatusLoading) then) =
      _$PiholeStatusLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$PiholeStatusLoadingCopyWithImpl<$Res>
    extends _$PiholeStatusCopyWithImpl<$Res>
    implements $PiholeStatusLoadingCopyWith<$Res> {
  _$PiholeStatusLoadingCopyWithImpl(
      PiholeStatusLoading _value, $Res Function(PiholeStatusLoading) _then)
      : super(_value, (v) => _then(v as PiholeStatusLoading));

  @override
  PiholeStatusLoading get _value => super._value as PiholeStatusLoading;
}

/// @nodoc

class _$PiholeStatusLoading implements PiholeStatusLoading {
  const _$PiholeStatusLoading();

  @override
  String toString() {
    return 'PiholeStatus.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is PiholeStatusLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() enabled,
    required TResult Function() disabled,
    required TResult Function(Duration duration, DateTime start) sleeping,
    required TResult Function(PiholeApiFailure failure) failure,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PiholeStatusLoading value) loading,
    required TResult Function(PiholeStatusEnabled value) enabled,
    required TResult Function(PiholeStatusDisabled value) disabled,
    required TResult Function(PiholeStatusSleeping value) sleeping,
    required TResult Function(PiholeStatusFailure value) failure,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PiholeStatusLoading implements PiholeStatus {
  const factory PiholeStatusLoading() = _$PiholeStatusLoading;
}

/// @nodoc
abstract class $PiholeStatusEnabledCopyWith<$Res> {
  factory $PiholeStatusEnabledCopyWith(
          PiholeStatusEnabled value, $Res Function(PiholeStatusEnabled) then) =
      _$PiholeStatusEnabledCopyWithImpl<$Res>;
}

/// @nodoc
class _$PiholeStatusEnabledCopyWithImpl<$Res>
    extends _$PiholeStatusCopyWithImpl<$Res>
    implements $PiholeStatusEnabledCopyWith<$Res> {
  _$PiholeStatusEnabledCopyWithImpl(
      PiholeStatusEnabled _value, $Res Function(PiholeStatusEnabled) _then)
      : super(_value, (v) => _then(v as PiholeStatusEnabled));

  @override
  PiholeStatusEnabled get _value => super._value as PiholeStatusEnabled;
}

/// @nodoc

class _$PiholeStatusEnabled implements PiholeStatusEnabled {
  const _$PiholeStatusEnabled();

  @override
  String toString() {
    return 'PiholeStatus.enabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is PiholeStatusEnabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() enabled,
    required TResult Function() disabled,
    required TResult Function(Duration duration, DateTime start) sleeping,
    required TResult Function(PiholeApiFailure failure) failure,
  }) {
    return enabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
  }) {
    return enabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
    required TResult orElse(),
  }) {
    if (enabled != null) {
      return enabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PiholeStatusLoading value) loading,
    required TResult Function(PiholeStatusEnabled value) enabled,
    required TResult Function(PiholeStatusDisabled value) disabled,
    required TResult Function(PiholeStatusSleeping value) sleeping,
    required TResult Function(PiholeStatusFailure value) failure,
  }) {
    return enabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
  }) {
    return enabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
    required TResult orElse(),
  }) {
    if (enabled != null) {
      return enabled(this);
    }
    return orElse();
  }
}

abstract class PiholeStatusEnabled implements PiholeStatus {
  const factory PiholeStatusEnabled() = _$PiholeStatusEnabled;
}

/// @nodoc
abstract class $PiholeStatusDisabledCopyWith<$Res> {
  factory $PiholeStatusDisabledCopyWith(PiholeStatusDisabled value,
          $Res Function(PiholeStatusDisabled) then) =
      _$PiholeStatusDisabledCopyWithImpl<$Res>;
}

/// @nodoc
class _$PiholeStatusDisabledCopyWithImpl<$Res>
    extends _$PiholeStatusCopyWithImpl<$Res>
    implements $PiholeStatusDisabledCopyWith<$Res> {
  _$PiholeStatusDisabledCopyWithImpl(
      PiholeStatusDisabled _value, $Res Function(PiholeStatusDisabled) _then)
      : super(_value, (v) => _then(v as PiholeStatusDisabled));

  @override
  PiholeStatusDisabled get _value => super._value as PiholeStatusDisabled;
}

/// @nodoc

class _$PiholeStatusDisabled implements PiholeStatusDisabled {
  const _$PiholeStatusDisabled();

  @override
  String toString() {
    return 'PiholeStatus.disabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is PiholeStatusDisabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() enabled,
    required TResult Function() disabled,
    required TResult Function(Duration duration, DateTime start) sleeping,
    required TResult Function(PiholeApiFailure failure) failure,
  }) {
    return disabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
  }) {
    return disabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PiholeStatusLoading value) loading,
    required TResult Function(PiholeStatusEnabled value) enabled,
    required TResult Function(PiholeStatusDisabled value) disabled,
    required TResult Function(PiholeStatusSleeping value) sleeping,
    required TResult Function(PiholeStatusFailure value) failure,
  }) {
    return disabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
  }) {
    return disabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled(this);
    }
    return orElse();
  }
}

abstract class PiholeStatusDisabled implements PiholeStatus {
  const factory PiholeStatusDisabled() = _$PiholeStatusDisabled;
}

/// @nodoc
abstract class $PiholeStatusSleepingCopyWith<$Res> {
  factory $PiholeStatusSleepingCopyWith(PiholeStatusSleeping value,
          $Res Function(PiholeStatusSleeping) then) =
      _$PiholeStatusSleepingCopyWithImpl<$Res>;
  $Res call({Duration duration, DateTime start});
}

/// @nodoc
class _$PiholeStatusSleepingCopyWithImpl<$Res>
    extends _$PiholeStatusCopyWithImpl<$Res>
    implements $PiholeStatusSleepingCopyWith<$Res> {
  _$PiholeStatusSleepingCopyWithImpl(
      PiholeStatusSleeping _value, $Res Function(PiholeStatusSleeping) _then)
      : super(_value, (v) => _then(v as PiholeStatusSleeping));

  @override
  PiholeStatusSleeping get _value => super._value as PiholeStatusSleeping;

  @override
  $Res call({
    Object? duration = freezed,
    Object? start = freezed,
  }) {
    return _then(PiholeStatusSleeping(
      duration == freezed
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      start == freezed
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$PiholeStatusSleeping implements PiholeStatusSleeping {
  const _$PiholeStatusSleeping(this.duration, this.start);

  @override
  final Duration duration;
  @override
  final DateTime start;

  @override
  String toString() {
    return 'PiholeStatus.sleeping(duration: $duration, start: $start)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PiholeStatusSleeping &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.start, start) || other.start == start));
  }

  @override
  int get hashCode => Object.hash(runtimeType, duration, start);

  @JsonKey(ignore: true)
  @override
  $PiholeStatusSleepingCopyWith<PiholeStatusSleeping> get copyWith =>
      _$PiholeStatusSleepingCopyWithImpl<PiholeStatusSleeping>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() enabled,
    required TResult Function() disabled,
    required TResult Function(Duration duration, DateTime start) sleeping,
    required TResult Function(PiholeApiFailure failure) failure,
  }) {
    return sleeping(duration, start);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
  }) {
    return sleeping?.call(duration, start);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
    required TResult orElse(),
  }) {
    if (sleeping != null) {
      return sleeping(duration, start);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PiholeStatusLoading value) loading,
    required TResult Function(PiholeStatusEnabled value) enabled,
    required TResult Function(PiholeStatusDisabled value) disabled,
    required TResult Function(PiholeStatusSleeping value) sleeping,
    required TResult Function(PiholeStatusFailure value) failure,
  }) {
    return sleeping(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
  }) {
    return sleeping?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
    required TResult orElse(),
  }) {
    if (sleeping != null) {
      return sleeping(this);
    }
    return orElse();
  }
}

abstract class PiholeStatusSleeping implements PiholeStatus {
  const factory PiholeStatusSleeping(Duration duration, DateTime start) =
      _$PiholeStatusSleeping;

  Duration get duration;
  DateTime get start;
  @JsonKey(ignore: true)
  $PiholeStatusSleepingCopyWith<PiholeStatusSleeping> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiholeStatusFailureCopyWith<$Res> {
  factory $PiholeStatusFailureCopyWith(
          PiholeStatusFailure value, $Res Function(PiholeStatusFailure) then) =
      _$PiholeStatusFailureCopyWithImpl<$Res>;
  $Res call({PiholeApiFailure failure});

  $PiholeApiFailureCopyWith<$Res> get failure;
}

/// @nodoc
class _$PiholeStatusFailureCopyWithImpl<$Res>
    extends _$PiholeStatusCopyWithImpl<$Res>
    implements $PiholeStatusFailureCopyWith<$Res> {
  _$PiholeStatusFailureCopyWithImpl(
      PiholeStatusFailure _value, $Res Function(PiholeStatusFailure) _then)
      : super(_value, (v) => _then(v as PiholeStatusFailure));

  @override
  PiholeStatusFailure get _value => super._value as PiholeStatusFailure;

  @override
  $Res call({
    Object? failure = freezed,
  }) {
    return _then(PiholeStatusFailure(
      failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as PiholeApiFailure,
    ));
  }

  @override
  $PiholeApiFailureCopyWith<$Res> get failure {
    return $PiholeApiFailureCopyWith<$Res>(_value.failure, (value) {
      return _then(_value.copyWith(failure: value));
    });
  }
}

/// @nodoc

class _$PiholeStatusFailure implements PiholeStatusFailure {
  const _$PiholeStatusFailure(this.failure);

  @override
  final PiholeApiFailure failure;

  @override
  String toString() {
    return 'PiholeStatus.failure(failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PiholeStatusFailure &&
            (identical(other.failure, failure) || other.failure == failure));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failure);

  @JsonKey(ignore: true)
  @override
  $PiholeStatusFailureCopyWith<PiholeStatusFailure> get copyWith =>
      _$PiholeStatusFailureCopyWithImpl<PiholeStatusFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() enabled,
    required TResult Function() disabled,
    required TResult Function(Duration duration, DateTime start) sleeping,
    required TResult Function(PiholeApiFailure failure) failure,
  }) {
    return failure(this.failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
  }) {
    return failure?.call(this.failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? enabled,
    TResult Function()? disabled,
    TResult Function(Duration duration, DateTime start)? sleeping,
    TResult Function(PiholeApiFailure failure)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this.failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PiholeStatusLoading value) loading,
    required TResult Function(PiholeStatusEnabled value) enabled,
    required TResult Function(PiholeStatusDisabled value) disabled,
    required TResult Function(PiholeStatusSleeping value) sleeping,
    required TResult Function(PiholeStatusFailure value) failure,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PiholeStatusLoading value)? loading,
    TResult Function(PiholeStatusEnabled value)? enabled,
    TResult Function(PiholeStatusDisabled value)? disabled,
    TResult Function(PiholeStatusSleeping value)? sleeping,
    TResult Function(PiholeStatusFailure value)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class PiholeStatusFailure implements PiholeStatus {
  const factory PiholeStatusFailure(PiholeApiFailure failure) =
      _$PiholeStatusFailure;

  PiholeApiFailure get failure;
  @JsonKey(ignore: true)
  $PiholeStatusFailureCopyWith<PiholeStatusFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiSummaryTearOff {
  const _$PiSummaryTearOff();

  _PiSummary call(
      {required int domainsBeingBlocked,
      required int dnsQueriesToday,
      required int adsBlockedToday,
      required double adsPercentageToday,
      required int uniqueDomains,
      required int queriesForwarded,
      required int queriesCached,
      required int clientsEverSeen,
      required int uniqueClients,
      required int dnsQueriesAllTypes,
      required int replyNoData,
      required int replyNxDomain,
      required int replyCName,
      required int replyIP,
      required int privacyLevel,
      required PiholeStatus status}) {
    return _PiSummary(
      domainsBeingBlocked: domainsBeingBlocked,
      dnsQueriesToday: dnsQueriesToday,
      adsBlockedToday: adsBlockedToday,
      adsPercentageToday: adsPercentageToday,
      uniqueDomains: uniqueDomains,
      queriesForwarded: queriesForwarded,
      queriesCached: queriesCached,
      clientsEverSeen: clientsEverSeen,
      uniqueClients: uniqueClients,
      dnsQueriesAllTypes: dnsQueriesAllTypes,
      replyNoData: replyNoData,
      replyNxDomain: replyNxDomain,
      replyCName: replyCName,
      replyIP: replyIP,
      privacyLevel: privacyLevel,
      status: status,
    );
  }
}

/// @nodoc
const $PiSummary = _$PiSummaryTearOff();

/// @nodoc
mixin _$PiSummary {
  int get domainsBeingBlocked => throw _privateConstructorUsedError;
  int get dnsQueriesToday => throw _privateConstructorUsedError;
  int get adsBlockedToday => throw _privateConstructorUsedError;
  double get adsPercentageToday => throw _privateConstructorUsedError;
  int get uniqueDomains => throw _privateConstructorUsedError;
  int get queriesForwarded => throw _privateConstructorUsedError;
  int get queriesCached => throw _privateConstructorUsedError;
  int get clientsEverSeen => throw _privateConstructorUsedError;
  int get uniqueClients => throw _privateConstructorUsedError;
  int get dnsQueriesAllTypes => throw _privateConstructorUsedError;
  int get replyNoData => throw _privateConstructorUsedError;
  int get replyNxDomain => throw _privateConstructorUsedError;
  int get replyCName => throw _privateConstructorUsedError;
  int get replyIP => throw _privateConstructorUsedError;
  int get privacyLevel => throw _privateConstructorUsedError;
  PiholeStatus get status => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiSummaryCopyWith<PiSummary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiSummaryCopyWith<$Res> {
  factory $PiSummaryCopyWith(PiSummary value, $Res Function(PiSummary) then) =
      _$PiSummaryCopyWithImpl<$Res>;
  $Res call(
      {int domainsBeingBlocked,
      int dnsQueriesToday,
      int adsBlockedToday,
      double adsPercentageToday,
      int uniqueDomains,
      int queriesForwarded,
      int queriesCached,
      int clientsEverSeen,
      int uniqueClients,
      int dnsQueriesAllTypes,
      int replyNoData,
      int replyNxDomain,
      int replyCName,
      int replyIP,
      int privacyLevel,
      PiholeStatus status});

  $PiholeStatusCopyWith<$Res> get status;
}

/// @nodoc
class _$PiSummaryCopyWithImpl<$Res> implements $PiSummaryCopyWith<$Res> {
  _$PiSummaryCopyWithImpl(this._value, this._then);

  final PiSummary _value;
  // ignore: unused_field
  final $Res Function(PiSummary) _then;

  @override
  $Res call({
    Object? domainsBeingBlocked = freezed,
    Object? dnsQueriesToday = freezed,
    Object? adsBlockedToday = freezed,
    Object? adsPercentageToday = freezed,
    Object? uniqueDomains = freezed,
    Object? queriesForwarded = freezed,
    Object? queriesCached = freezed,
    Object? clientsEverSeen = freezed,
    Object? uniqueClients = freezed,
    Object? dnsQueriesAllTypes = freezed,
    Object? replyNoData = freezed,
    Object? replyNxDomain = freezed,
    Object? replyCName = freezed,
    Object? replyIP = freezed,
    Object? privacyLevel = freezed,
    Object? status = freezed,
  }) {
    return _then(_value.copyWith(
      domainsBeingBlocked: domainsBeingBlocked == freezed
          ? _value.domainsBeingBlocked
          : domainsBeingBlocked // ignore: cast_nullable_to_non_nullable
              as int,
      dnsQueriesToday: dnsQueriesToday == freezed
          ? _value.dnsQueriesToday
          : dnsQueriesToday // ignore: cast_nullable_to_non_nullable
              as int,
      adsBlockedToday: adsBlockedToday == freezed
          ? _value.adsBlockedToday
          : adsBlockedToday // ignore: cast_nullable_to_non_nullable
              as int,
      adsPercentageToday: adsPercentageToday == freezed
          ? _value.adsPercentageToday
          : adsPercentageToday // ignore: cast_nullable_to_non_nullable
              as double,
      uniqueDomains: uniqueDomains == freezed
          ? _value.uniqueDomains
          : uniqueDomains // ignore: cast_nullable_to_non_nullable
              as int,
      queriesForwarded: queriesForwarded == freezed
          ? _value.queriesForwarded
          : queriesForwarded // ignore: cast_nullable_to_non_nullable
              as int,
      queriesCached: queriesCached == freezed
          ? _value.queriesCached
          : queriesCached // ignore: cast_nullable_to_non_nullable
              as int,
      clientsEverSeen: clientsEverSeen == freezed
          ? _value.clientsEverSeen
          : clientsEverSeen // ignore: cast_nullable_to_non_nullable
              as int,
      uniqueClients: uniqueClients == freezed
          ? _value.uniqueClients
          : uniqueClients // ignore: cast_nullable_to_non_nullable
              as int,
      dnsQueriesAllTypes: dnsQueriesAllTypes == freezed
          ? _value.dnsQueriesAllTypes
          : dnsQueriesAllTypes // ignore: cast_nullable_to_non_nullable
              as int,
      replyNoData: replyNoData == freezed
          ? _value.replyNoData
          : replyNoData // ignore: cast_nullable_to_non_nullable
              as int,
      replyNxDomain: replyNxDomain == freezed
          ? _value.replyNxDomain
          : replyNxDomain // ignore: cast_nullable_to_non_nullable
              as int,
      replyCName: replyCName == freezed
          ? _value.replyCName
          : replyCName // ignore: cast_nullable_to_non_nullable
              as int,
      replyIP: replyIP == freezed
          ? _value.replyIP
          : replyIP // ignore: cast_nullable_to_non_nullable
              as int,
      privacyLevel: privacyLevel == freezed
          ? _value.privacyLevel
          : privacyLevel // ignore: cast_nullable_to_non_nullable
              as int,
      status: status == freezed
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as PiholeStatus,
    ));
  }

  @override
  $PiholeStatusCopyWith<$Res> get status {
    return $PiholeStatusCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }
}

/// @nodoc
abstract class _$PiSummaryCopyWith<$Res> implements $PiSummaryCopyWith<$Res> {
  factory _$PiSummaryCopyWith(
          _PiSummary value, $Res Function(_PiSummary) then) =
      __$PiSummaryCopyWithImpl<$Res>;
  @override
  $Res call(
      {int domainsBeingBlocked,
      int dnsQueriesToday,
      int adsBlockedToday,
      double adsPercentageToday,
      int uniqueDomains,
      int queriesForwarded,
      int queriesCached,
      int clientsEverSeen,
      int uniqueClients,
      int dnsQueriesAllTypes,
      int replyNoData,
      int replyNxDomain,
      int replyCName,
      int replyIP,
      int privacyLevel,
      PiholeStatus status});

  @override
  $PiholeStatusCopyWith<$Res> get status;
}

/// @nodoc
class __$PiSummaryCopyWithImpl<$Res> extends _$PiSummaryCopyWithImpl<$Res>
    implements _$PiSummaryCopyWith<$Res> {
  __$PiSummaryCopyWithImpl(_PiSummary _value, $Res Function(_PiSummary) _then)
      : super(_value, (v) => _then(v as _PiSummary));

  @override
  _PiSummary get _value => super._value as _PiSummary;

  @override
  $Res call({
    Object? domainsBeingBlocked = freezed,
    Object? dnsQueriesToday = freezed,
    Object? adsBlockedToday = freezed,
    Object? adsPercentageToday = freezed,
    Object? uniqueDomains = freezed,
    Object? queriesForwarded = freezed,
    Object? queriesCached = freezed,
    Object? clientsEverSeen = freezed,
    Object? uniqueClients = freezed,
    Object? dnsQueriesAllTypes = freezed,
    Object? replyNoData = freezed,
    Object? replyNxDomain = freezed,
    Object? replyCName = freezed,
    Object? replyIP = freezed,
    Object? privacyLevel = freezed,
    Object? status = freezed,
  }) {
    return _then(_PiSummary(
      domainsBeingBlocked: domainsBeingBlocked == freezed
          ? _value.domainsBeingBlocked
          : domainsBeingBlocked // ignore: cast_nullable_to_non_nullable
              as int,
      dnsQueriesToday: dnsQueriesToday == freezed
          ? _value.dnsQueriesToday
          : dnsQueriesToday // ignore: cast_nullable_to_non_nullable
              as int,
      adsBlockedToday: adsBlockedToday == freezed
          ? _value.adsBlockedToday
          : adsBlockedToday // ignore: cast_nullable_to_non_nullable
              as int,
      adsPercentageToday: adsPercentageToday == freezed
          ? _value.adsPercentageToday
          : adsPercentageToday // ignore: cast_nullable_to_non_nullable
              as double,
      uniqueDomains: uniqueDomains == freezed
          ? _value.uniqueDomains
          : uniqueDomains // ignore: cast_nullable_to_non_nullable
              as int,
      queriesForwarded: queriesForwarded == freezed
          ? _value.queriesForwarded
          : queriesForwarded // ignore: cast_nullable_to_non_nullable
              as int,
      queriesCached: queriesCached == freezed
          ? _value.queriesCached
          : queriesCached // ignore: cast_nullable_to_non_nullable
              as int,
      clientsEverSeen: clientsEverSeen == freezed
          ? _value.clientsEverSeen
          : clientsEverSeen // ignore: cast_nullable_to_non_nullable
              as int,
      uniqueClients: uniqueClients == freezed
          ? _value.uniqueClients
          : uniqueClients // ignore: cast_nullable_to_non_nullable
              as int,
      dnsQueriesAllTypes: dnsQueriesAllTypes == freezed
          ? _value.dnsQueriesAllTypes
          : dnsQueriesAllTypes // ignore: cast_nullable_to_non_nullable
              as int,
      replyNoData: replyNoData == freezed
          ? _value.replyNoData
          : replyNoData // ignore: cast_nullable_to_non_nullable
              as int,
      replyNxDomain: replyNxDomain == freezed
          ? _value.replyNxDomain
          : replyNxDomain // ignore: cast_nullable_to_non_nullable
              as int,
      replyCName: replyCName == freezed
          ? _value.replyCName
          : replyCName // ignore: cast_nullable_to_non_nullable
              as int,
      replyIP: replyIP == freezed
          ? _value.replyIP
          : replyIP // ignore: cast_nullable_to_non_nullable
              as int,
      privacyLevel: privacyLevel == freezed
          ? _value.privacyLevel
          : privacyLevel // ignore: cast_nullable_to_non_nullable
              as int,
      status: status == freezed
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as PiholeStatus,
    ));
  }
}

/// @nodoc

class _$_PiSummary implements _PiSummary {
  const _$_PiSummary(
      {required this.domainsBeingBlocked,
      required this.dnsQueriesToday,
      required this.adsBlockedToday,
      required this.adsPercentageToday,
      required this.uniqueDomains,
      required this.queriesForwarded,
      required this.queriesCached,
      required this.clientsEverSeen,
      required this.uniqueClients,
      required this.dnsQueriesAllTypes,
      required this.replyNoData,
      required this.replyNxDomain,
      required this.replyCName,
      required this.replyIP,
      required this.privacyLevel,
      required this.status});

  @override
  final int domainsBeingBlocked;
  @override
  final int dnsQueriesToday;
  @override
  final int adsBlockedToday;
  @override
  final double adsPercentageToday;
  @override
  final int uniqueDomains;
  @override
  final int queriesForwarded;
  @override
  final int queriesCached;
  @override
  final int clientsEverSeen;
  @override
  final int uniqueClients;
  @override
  final int dnsQueriesAllTypes;
  @override
  final int replyNoData;
  @override
  final int replyNxDomain;
  @override
  final int replyCName;
  @override
  final int replyIP;
  @override
  final int privacyLevel;
  @override
  final PiholeStatus status;

  @override
  String toString() {
    return 'PiSummary(domainsBeingBlocked: $domainsBeingBlocked, dnsQueriesToday: $dnsQueriesToday, adsBlockedToday: $adsBlockedToday, adsPercentageToday: $adsPercentageToday, uniqueDomains: $uniqueDomains, queriesForwarded: $queriesForwarded, queriesCached: $queriesCached, clientsEverSeen: $clientsEverSeen, uniqueClients: $uniqueClients, dnsQueriesAllTypes: $dnsQueriesAllTypes, replyNoData: $replyNoData, replyNxDomain: $replyNxDomain, replyCName: $replyCName, replyIP: $replyIP, privacyLevel: $privacyLevel, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiSummary &&
            (identical(other.domainsBeingBlocked, domainsBeingBlocked) ||
                other.domainsBeingBlocked == domainsBeingBlocked) &&
            (identical(other.dnsQueriesToday, dnsQueriesToday) ||
                other.dnsQueriesToday == dnsQueriesToday) &&
            (identical(other.adsBlockedToday, adsBlockedToday) ||
                other.adsBlockedToday == adsBlockedToday) &&
            (identical(other.adsPercentageToday, adsPercentageToday) ||
                other.adsPercentageToday == adsPercentageToday) &&
            (identical(other.uniqueDomains, uniqueDomains) ||
                other.uniqueDomains == uniqueDomains) &&
            (identical(other.queriesForwarded, queriesForwarded) ||
                other.queriesForwarded == queriesForwarded) &&
            (identical(other.queriesCached, queriesCached) ||
                other.queriesCached == queriesCached) &&
            (identical(other.clientsEverSeen, clientsEverSeen) ||
                other.clientsEverSeen == clientsEverSeen) &&
            (identical(other.uniqueClients, uniqueClients) ||
                other.uniqueClients == uniqueClients) &&
            (identical(other.dnsQueriesAllTypes, dnsQueriesAllTypes) ||
                other.dnsQueriesAllTypes == dnsQueriesAllTypes) &&
            (identical(other.replyNoData, replyNoData) ||
                other.replyNoData == replyNoData) &&
            (identical(other.replyNxDomain, replyNxDomain) ||
                other.replyNxDomain == replyNxDomain) &&
            (identical(other.replyCName, replyCName) ||
                other.replyCName == replyCName) &&
            (identical(other.replyIP, replyIP) || other.replyIP == replyIP) &&
            (identical(other.privacyLevel, privacyLevel) ||
                other.privacyLevel == privacyLevel) &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      domainsBeingBlocked,
      dnsQueriesToday,
      adsBlockedToday,
      adsPercentageToday,
      uniqueDomains,
      queriesForwarded,
      queriesCached,
      clientsEverSeen,
      uniqueClients,
      dnsQueriesAllTypes,
      replyNoData,
      replyNxDomain,
      replyCName,
      replyIP,
      privacyLevel,
      status);

  @JsonKey(ignore: true)
  @override
  _$PiSummaryCopyWith<_PiSummary> get copyWith =>
      __$PiSummaryCopyWithImpl<_PiSummary>(this, _$identity);
}

abstract class _PiSummary implements PiSummary {
  const factory _PiSummary(
      {required int domainsBeingBlocked,
      required int dnsQueriesToday,
      required int adsBlockedToday,
      required double adsPercentageToday,
      required int uniqueDomains,
      required int queriesForwarded,
      required int queriesCached,
      required int clientsEverSeen,
      required int uniqueClients,
      required int dnsQueriesAllTypes,
      required int replyNoData,
      required int replyNxDomain,
      required int replyCName,
      required int replyIP,
      required int privacyLevel,
      required PiholeStatus status}) = _$_PiSummary;

  @override
  int get domainsBeingBlocked;
  @override
  int get dnsQueriesToday;
  @override
  int get adsBlockedToday;
  @override
  double get adsPercentageToday;
  @override
  int get uniqueDomains;
  @override
  int get queriesForwarded;
  @override
  int get queriesCached;
  @override
  int get clientsEverSeen;
  @override
  int get uniqueClients;
  @override
  int get dnsQueriesAllTypes;
  @override
  int get replyNoData;
  @override
  int get replyNxDomain;
  @override
  int get replyCName;
  @override
  int get replyIP;
  @override
  int get privacyLevel;
  @override
  PiholeStatus get status;
  @override
  @JsonKey(ignore: true)
  _$PiSummaryCopyWith<_PiSummary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiDetailsTearOff {
  const _$PiDetailsTearOff();

  _PiDetails call(
      {required double? temperature,
      required List<double> cpuLoads,
      required double? memoryUsage}) {
    return _PiDetails(
      temperature: temperature,
      cpuLoads: cpuLoads,
      memoryUsage: memoryUsage,
    );
  }
}

/// @nodoc
const $PiDetails = _$PiDetailsTearOff();

/// @nodoc
mixin _$PiDetails {
  double? get temperature => throw _privateConstructorUsedError;
  List<double> get cpuLoads => throw _privateConstructorUsedError;
  double? get memoryUsage => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiDetailsCopyWith<PiDetails> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiDetailsCopyWith<$Res> {
  factory $PiDetailsCopyWith(PiDetails value, $Res Function(PiDetails) then) =
      _$PiDetailsCopyWithImpl<$Res>;
  $Res call({double? temperature, List<double> cpuLoads, double? memoryUsage});
}

/// @nodoc
class _$PiDetailsCopyWithImpl<$Res> implements $PiDetailsCopyWith<$Res> {
  _$PiDetailsCopyWithImpl(this._value, this._then);

  final PiDetails _value;
  // ignore: unused_field
  final $Res Function(PiDetails) _then;

  @override
  $Res call({
    Object? temperature = freezed,
    Object? cpuLoads = freezed,
    Object? memoryUsage = freezed,
  }) {
    return _then(_value.copyWith(
      temperature: temperature == freezed
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      cpuLoads: cpuLoads == freezed
          ? _value.cpuLoads
          : cpuLoads // ignore: cast_nullable_to_non_nullable
              as List<double>,
      memoryUsage: memoryUsage == freezed
          ? _value.memoryUsage
          : memoryUsage // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
abstract class _$PiDetailsCopyWith<$Res> implements $PiDetailsCopyWith<$Res> {
  factory _$PiDetailsCopyWith(
          _PiDetails value, $Res Function(_PiDetails) then) =
      __$PiDetailsCopyWithImpl<$Res>;
  @override
  $Res call({double? temperature, List<double> cpuLoads, double? memoryUsage});
}

/// @nodoc
class __$PiDetailsCopyWithImpl<$Res> extends _$PiDetailsCopyWithImpl<$Res>
    implements _$PiDetailsCopyWith<$Res> {
  __$PiDetailsCopyWithImpl(_PiDetails _value, $Res Function(_PiDetails) _then)
      : super(_value, (v) => _then(v as _PiDetails));

  @override
  _PiDetails get _value => super._value as _PiDetails;

  @override
  $Res call({
    Object? temperature = freezed,
    Object? cpuLoads = freezed,
    Object? memoryUsage = freezed,
  }) {
    return _then(_PiDetails(
      temperature: temperature == freezed
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double?,
      cpuLoads: cpuLoads == freezed
          ? _value.cpuLoads
          : cpuLoads // ignore: cast_nullable_to_non_nullable
              as List<double>,
      memoryUsage: memoryUsage == freezed
          ? _value.memoryUsage
          : memoryUsage // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$_PiDetails extends _PiDetails {
  _$_PiDetails(
      {required this.temperature,
      required this.cpuLoads,
      required this.memoryUsage})
      : super._();

  @override
  final double? temperature;
  @override
  final List<double> cpuLoads;
  @override
  final double? memoryUsage;

  @override
  String toString() {
    return 'PiDetails(temperature: $temperature, cpuLoads: $cpuLoads, memoryUsage: $memoryUsage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiDetails &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            const DeepCollectionEquality().equals(other.cpuLoads, cpuLoads) &&
            (identical(other.memoryUsage, memoryUsage) ||
                other.memoryUsage == memoryUsage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, temperature,
      const DeepCollectionEquality().hash(cpuLoads), memoryUsage);

  @JsonKey(ignore: true)
  @override
  _$PiDetailsCopyWith<_PiDetails> get copyWith =>
      __$PiDetailsCopyWithImpl<_PiDetails>(this, _$identity);
}

abstract class _PiDetails extends PiDetails {
  factory _PiDetails(
      {required double? temperature,
      required List<double> cpuLoads,
      required double? memoryUsage}) = _$_PiDetails;
  _PiDetails._() : super._();

  @override
  double? get temperature;
  @override
  List<double> get cpuLoads;
  @override
  double? get memoryUsage;
  @override
  @JsonKey(ignore: true)
  _$PiDetailsCopyWith<_PiDetails> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiQueryTypesTearOff {
  const _$PiQueryTypesTearOff();

  _PiQueryTypes call({required Map<String, double> types}) {
    return _PiQueryTypes(
      types: types,
    );
  }
}

/// @nodoc
const $PiQueryTypes = _$PiQueryTypesTearOff();

/// @nodoc
mixin _$PiQueryTypes {
  Map<String, double> get types => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiQueryTypesCopyWith<PiQueryTypes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiQueryTypesCopyWith<$Res> {
  factory $PiQueryTypesCopyWith(
          PiQueryTypes value, $Res Function(PiQueryTypes) then) =
      _$PiQueryTypesCopyWithImpl<$Res>;
  $Res call({Map<String, double> types});
}

/// @nodoc
class _$PiQueryTypesCopyWithImpl<$Res> implements $PiQueryTypesCopyWith<$Res> {
  _$PiQueryTypesCopyWithImpl(this._value, this._then);

  final PiQueryTypes _value;
  // ignore: unused_field
  final $Res Function(PiQueryTypes) _then;

  @override
  $Res call({
    Object? types = freezed,
  }) {
    return _then(_value.copyWith(
      types: types == freezed
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
    ));
  }
}

/// @nodoc
abstract class _$PiQueryTypesCopyWith<$Res>
    implements $PiQueryTypesCopyWith<$Res> {
  factory _$PiQueryTypesCopyWith(
          _PiQueryTypes value, $Res Function(_PiQueryTypes) then) =
      __$PiQueryTypesCopyWithImpl<$Res>;
  @override
  $Res call({Map<String, double> types});
}

/// @nodoc
class __$PiQueryTypesCopyWithImpl<$Res> extends _$PiQueryTypesCopyWithImpl<$Res>
    implements _$PiQueryTypesCopyWith<$Res> {
  __$PiQueryTypesCopyWithImpl(
      _PiQueryTypes _value, $Res Function(_PiQueryTypes) _then)
      : super(_value, (v) => _then(v as _PiQueryTypes));

  @override
  _PiQueryTypes get _value => super._value as _PiQueryTypes;

  @override
  $Res call({
    Object? types = freezed,
  }) {
    return _then(_PiQueryTypes(
      types: types == freezed
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
    ));
  }
}

/// @nodoc

class _$_PiQueryTypes implements _PiQueryTypes {
  _$_PiQueryTypes({required this.types});

  @override
  final Map<String, double> types;

  @override
  String toString() {
    return 'PiQueryTypes(types: $types)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiQueryTypes &&
            const DeepCollectionEquality().equals(other.types, types));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(types));

  @JsonKey(ignore: true)
  @override
  _$PiQueryTypesCopyWith<_PiQueryTypes> get copyWith =>
      __$PiQueryTypesCopyWithImpl<_PiQueryTypes>(this, _$identity);
}

abstract class _PiQueryTypes implements PiQueryTypes {
  factory _PiQueryTypes({required Map<String, double> types}) = _$_PiQueryTypes;

  @override
  Map<String, double> get types;
  @override
  @JsonKey(ignore: true)
  _$PiQueryTypesCopyWith<_PiQueryTypes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiForwardDestinationsTearOff {
  const _$PiForwardDestinationsTearOff();

  _PiForwardDestinations call({required Map<String, double> destinations}) {
    return _PiForwardDestinations(
      destinations: destinations,
    );
  }
}

/// @nodoc
const $PiForwardDestinations = _$PiForwardDestinationsTearOff();

/// @nodoc
mixin _$PiForwardDestinations {
  Map<String, double> get destinations => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiForwardDestinationsCopyWith<PiForwardDestinations> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiForwardDestinationsCopyWith<$Res> {
  factory $PiForwardDestinationsCopyWith(PiForwardDestinations value,
          $Res Function(PiForwardDestinations) then) =
      _$PiForwardDestinationsCopyWithImpl<$Res>;
  $Res call({Map<String, double> destinations});
}

/// @nodoc
class _$PiForwardDestinationsCopyWithImpl<$Res>
    implements $PiForwardDestinationsCopyWith<$Res> {
  _$PiForwardDestinationsCopyWithImpl(this._value, this._then);

  final PiForwardDestinations _value;
  // ignore: unused_field
  final $Res Function(PiForwardDestinations) _then;

  @override
  $Res call({
    Object? destinations = freezed,
  }) {
    return _then(_value.copyWith(
      destinations: destinations == freezed
          ? _value.destinations
          : destinations // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
    ));
  }
}

/// @nodoc
abstract class _$PiForwardDestinationsCopyWith<$Res>
    implements $PiForwardDestinationsCopyWith<$Res> {
  factory _$PiForwardDestinationsCopyWith(_PiForwardDestinations value,
          $Res Function(_PiForwardDestinations) then) =
      __$PiForwardDestinationsCopyWithImpl<$Res>;
  @override
  $Res call({Map<String, double> destinations});
}

/// @nodoc
class __$PiForwardDestinationsCopyWithImpl<$Res>
    extends _$PiForwardDestinationsCopyWithImpl<$Res>
    implements _$PiForwardDestinationsCopyWith<$Res> {
  __$PiForwardDestinationsCopyWithImpl(_PiForwardDestinations _value,
      $Res Function(_PiForwardDestinations) _then)
      : super(_value, (v) => _then(v as _PiForwardDestinations));

  @override
  _PiForwardDestinations get _value => super._value as _PiForwardDestinations;

  @override
  $Res call({
    Object? destinations = freezed,
  }) {
    return _then(_PiForwardDestinations(
      destinations: destinations == freezed
          ? _value.destinations
          : destinations // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
    ));
  }
}

/// @nodoc

class _$_PiForwardDestinations implements _PiForwardDestinations {
  _$_PiForwardDestinations({required this.destinations});

  @override
  final Map<String, double> destinations;

  @override
  String toString() {
    return 'PiForwardDestinations(destinations: $destinations)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiForwardDestinations &&
            const DeepCollectionEquality()
                .equals(other.destinations, destinations));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(destinations));

  @JsonKey(ignore: true)
  @override
  _$PiForwardDestinationsCopyWith<_PiForwardDestinations> get copyWith =>
      __$PiForwardDestinationsCopyWithImpl<_PiForwardDestinations>(
          this, _$identity);
}

abstract class _PiForwardDestinations implements PiForwardDestinations {
  factory _PiForwardDestinations({required Map<String, double> destinations}) =
      _$_PiForwardDestinations;

  @override
  Map<String, double> get destinations;
  @override
  @JsonKey(ignore: true)
  _$PiForwardDestinationsCopyWith<_PiForwardDestinations> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiQueriesOverTimeTearOff {
  const _$PiQueriesOverTimeTearOff();

  _PiQueriesOverTime call(
      {required Map<DateTime, int> domainsOverTime,
      required Map<DateTime, int> adsOverTime}) {
    return _PiQueriesOverTime(
      domainsOverTime: domainsOverTime,
      adsOverTime: adsOverTime,
    );
  }
}

/// @nodoc
const $PiQueriesOverTime = _$PiQueriesOverTimeTearOff();

/// @nodoc
mixin _$PiQueriesOverTime {
  Map<DateTime, int> get domainsOverTime => throw _privateConstructorUsedError;
  Map<DateTime, int> get adsOverTime => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiQueriesOverTimeCopyWith<PiQueriesOverTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiQueriesOverTimeCopyWith<$Res> {
  factory $PiQueriesOverTimeCopyWith(
          PiQueriesOverTime value, $Res Function(PiQueriesOverTime) then) =
      _$PiQueriesOverTimeCopyWithImpl<$Res>;
  $Res call(
      {Map<DateTime, int> domainsOverTime, Map<DateTime, int> adsOverTime});
}

/// @nodoc
class _$PiQueriesOverTimeCopyWithImpl<$Res>
    implements $PiQueriesOverTimeCopyWith<$Res> {
  _$PiQueriesOverTimeCopyWithImpl(this._value, this._then);

  final PiQueriesOverTime _value;
  // ignore: unused_field
  final $Res Function(PiQueriesOverTime) _then;

  @override
  $Res call({
    Object? domainsOverTime = freezed,
    Object? adsOverTime = freezed,
  }) {
    return _then(_value.copyWith(
      domainsOverTime: domainsOverTime == freezed
          ? _value.domainsOverTime
          : domainsOverTime // ignore: cast_nullable_to_non_nullable
              as Map<DateTime, int>,
      adsOverTime: adsOverTime == freezed
          ? _value.adsOverTime
          : adsOverTime // ignore: cast_nullable_to_non_nullable
              as Map<DateTime, int>,
    ));
  }
}

/// @nodoc
abstract class _$PiQueriesOverTimeCopyWith<$Res>
    implements $PiQueriesOverTimeCopyWith<$Res> {
  factory _$PiQueriesOverTimeCopyWith(
          _PiQueriesOverTime value, $Res Function(_PiQueriesOverTime) then) =
      __$PiQueriesOverTimeCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<DateTime, int> domainsOverTime, Map<DateTime, int> adsOverTime});
}

/// @nodoc
class __$PiQueriesOverTimeCopyWithImpl<$Res>
    extends _$PiQueriesOverTimeCopyWithImpl<$Res>
    implements _$PiQueriesOverTimeCopyWith<$Res> {
  __$PiQueriesOverTimeCopyWithImpl(
      _PiQueriesOverTime _value, $Res Function(_PiQueriesOverTime) _then)
      : super(_value, (v) => _then(v as _PiQueriesOverTime));

  @override
  _PiQueriesOverTime get _value => super._value as _PiQueriesOverTime;

  @override
  $Res call({
    Object? domainsOverTime = freezed,
    Object? adsOverTime = freezed,
  }) {
    return _then(_PiQueriesOverTime(
      domainsOverTime: domainsOverTime == freezed
          ? _value.domainsOverTime
          : domainsOverTime // ignore: cast_nullable_to_non_nullable
              as Map<DateTime, int>,
      adsOverTime: adsOverTime == freezed
          ? _value.adsOverTime
          : adsOverTime // ignore: cast_nullable_to_non_nullable
              as Map<DateTime, int>,
    ));
  }
}

/// @nodoc

class _$_PiQueriesOverTime extends _PiQueriesOverTime {
  _$_PiQueriesOverTime(
      {required this.domainsOverTime, required this.adsOverTime})
      : super._();

  @override
  final Map<DateTime, int> domainsOverTime;
  @override
  final Map<DateTime, int> adsOverTime;

  @override
  String toString() {
    return 'PiQueriesOverTime(domainsOverTime: $domainsOverTime, adsOverTime: $adsOverTime)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiQueriesOverTime &&
            const DeepCollectionEquality()
                .equals(other.domainsOverTime, domainsOverTime) &&
            const DeepCollectionEquality()
                .equals(other.adsOverTime, adsOverTime));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(domainsOverTime),
      const DeepCollectionEquality().hash(adsOverTime));

  @JsonKey(ignore: true)
  @override
  _$PiQueriesOverTimeCopyWith<_PiQueriesOverTime> get copyWith =>
      __$PiQueriesOverTimeCopyWithImpl<_PiQueriesOverTime>(this, _$identity);
}

abstract class _PiQueriesOverTime extends PiQueriesOverTime {
  factory _PiQueriesOverTime(
      {required Map<DateTime, int> domainsOverTime,
      required Map<DateTime, int> adsOverTime}) = _$_PiQueriesOverTime;
  _PiQueriesOverTime._() : super._();

  @override
  Map<DateTime, int> get domainsOverTime;
  @override
  Map<DateTime, int> get adsOverTime;
  @override
  @JsonKey(ignore: true)
  _$PiQueriesOverTimeCopyWith<_PiQueriesOverTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$QueryItemTearOff {
  const _$QueryItemTearOff();

  _QueryItem call(
      {required DateTime timestamp,
      required String queryType,
      required String domain,
      required String clientName,
      required QueryStatus queryStatus,
      required DnsSecStatus dnsSecStatus,
      required double delta}) {
    return _QueryItem(
      timestamp: timestamp,
      queryType: queryType,
      domain: domain,
      clientName: clientName,
      queryStatus: queryStatus,
      dnsSecStatus: dnsSecStatus,
      delta: delta,
    );
  }
}

/// @nodoc
const $QueryItem = _$QueryItemTearOff();

/// @nodoc
mixin _$QueryItem {
  DateTime get timestamp => throw _privateConstructorUsedError;
  String get queryType => throw _privateConstructorUsedError;
  String get domain => throw _privateConstructorUsedError;
  String get clientName => throw _privateConstructorUsedError;
  QueryStatus get queryStatus => throw _privateConstructorUsedError;
  DnsSecStatus get dnsSecStatus => throw _privateConstructorUsedError;
  double get delta => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $QueryItemCopyWith<QueryItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QueryItemCopyWith<$Res> {
  factory $QueryItemCopyWith(QueryItem value, $Res Function(QueryItem) then) =
      _$QueryItemCopyWithImpl<$Res>;
  $Res call(
      {DateTime timestamp,
      String queryType,
      String domain,
      String clientName,
      QueryStatus queryStatus,
      DnsSecStatus dnsSecStatus,
      double delta});
}

/// @nodoc
class _$QueryItemCopyWithImpl<$Res> implements $QueryItemCopyWith<$Res> {
  _$QueryItemCopyWithImpl(this._value, this._then);

  final QueryItem _value;
  // ignore: unused_field
  final $Res Function(QueryItem) _then;

  @override
  $Res call({
    Object? timestamp = freezed,
    Object? queryType = freezed,
    Object? domain = freezed,
    Object? clientName = freezed,
    Object? queryStatus = freezed,
    Object? dnsSecStatus = freezed,
    Object? delta = freezed,
  }) {
    return _then(_value.copyWith(
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      queryType: queryType == freezed
          ? _value.queryType
          : queryType // ignore: cast_nullable_to_non_nullable
              as String,
      domain: domain == freezed
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as String,
      clientName: clientName == freezed
          ? _value.clientName
          : clientName // ignore: cast_nullable_to_non_nullable
              as String,
      queryStatus: queryStatus == freezed
          ? _value.queryStatus
          : queryStatus // ignore: cast_nullable_to_non_nullable
              as QueryStatus,
      dnsSecStatus: dnsSecStatus == freezed
          ? _value.dnsSecStatus
          : dnsSecStatus // ignore: cast_nullable_to_non_nullable
              as DnsSecStatus,
      delta: delta == freezed
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$QueryItemCopyWith<$Res> implements $QueryItemCopyWith<$Res> {
  factory _$QueryItemCopyWith(
          _QueryItem value, $Res Function(_QueryItem) then) =
      __$QueryItemCopyWithImpl<$Res>;
  @override
  $Res call(
      {DateTime timestamp,
      String queryType,
      String domain,
      String clientName,
      QueryStatus queryStatus,
      DnsSecStatus dnsSecStatus,
      double delta});
}

/// @nodoc
class __$QueryItemCopyWithImpl<$Res> extends _$QueryItemCopyWithImpl<$Res>
    implements _$QueryItemCopyWith<$Res> {
  __$QueryItemCopyWithImpl(_QueryItem _value, $Res Function(_QueryItem) _then)
      : super(_value, (v) => _then(v as _QueryItem));

  @override
  _QueryItem get _value => super._value as _QueryItem;

  @override
  $Res call({
    Object? timestamp = freezed,
    Object? queryType = freezed,
    Object? domain = freezed,
    Object? clientName = freezed,
    Object? queryStatus = freezed,
    Object? dnsSecStatus = freezed,
    Object? delta = freezed,
  }) {
    return _then(_QueryItem(
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      queryType: queryType == freezed
          ? _value.queryType
          : queryType // ignore: cast_nullable_to_non_nullable
              as String,
      domain: domain == freezed
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as String,
      clientName: clientName == freezed
          ? _value.clientName
          : clientName // ignore: cast_nullable_to_non_nullable
              as String,
      queryStatus: queryStatus == freezed
          ? _value.queryStatus
          : queryStatus // ignore: cast_nullable_to_non_nullable
              as QueryStatus,
      dnsSecStatus: dnsSecStatus == freezed
          ? _value.dnsSecStatus
          : dnsSecStatus // ignore: cast_nullable_to_non_nullable
              as DnsSecStatus,
      delta: delta == freezed
          ? _value.delta
          : delta // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_QueryItem extends _QueryItem {
  _$_QueryItem(
      {required this.timestamp,
      required this.queryType,
      required this.domain,
      required this.clientName,
      required this.queryStatus,
      required this.dnsSecStatus,
      required this.delta})
      : super._();

  @override
  final DateTime timestamp;
  @override
  final String queryType;
  @override
  final String domain;
  @override
  final String clientName;
  @override
  final QueryStatus queryStatus;
  @override
  final DnsSecStatus dnsSecStatus;
  @override
  final double delta;

  @override
  String toString() {
    return 'QueryItem(timestamp: $timestamp, queryType: $queryType, domain: $domain, clientName: $clientName, queryStatus: $queryStatus, dnsSecStatus: $dnsSecStatus, delta: $delta)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _QueryItem &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.queryType, queryType) ||
                other.queryType == queryType) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            (identical(other.clientName, clientName) ||
                other.clientName == clientName) &&
            (identical(other.queryStatus, queryStatus) ||
                other.queryStatus == queryStatus) &&
            (identical(other.dnsSecStatus, dnsSecStatus) ||
                other.dnsSecStatus == dnsSecStatus) &&
            (identical(other.delta, delta) || other.delta == delta));
  }

  @override
  int get hashCode => Object.hash(runtimeType, timestamp, queryType, domain,
      clientName, queryStatus, dnsSecStatus, delta);

  @JsonKey(ignore: true)
  @override
  _$QueryItemCopyWith<_QueryItem> get copyWith =>
      __$QueryItemCopyWithImpl<_QueryItem>(this, _$identity);
}

abstract class _QueryItem extends QueryItem {
  factory _QueryItem(
      {required DateTime timestamp,
      required String queryType,
      required String domain,
      required String clientName,
      required QueryStatus queryStatus,
      required DnsSecStatus dnsSecStatus,
      required double delta}) = _$_QueryItem;
  _QueryItem._() : super._();

  @override
  DateTime get timestamp;
  @override
  String get queryType;
  @override
  String get domain;
  @override
  String get clientName;
  @override
  QueryStatus get queryStatus;
  @override
  DnsSecStatus get dnsSecStatus;
  @override
  double get delta;
  @override
  @JsonKey(ignore: true)
  _$QueryItemCopyWith<_QueryItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$TopItemsTearOff {
  const _$TopItemsTearOff();

  _TopItems call(
      {required Map<String, int> topQueries,
      required Map<String, int> topAds}) {
    return _TopItems(
      topQueries: topQueries,
      topAds: topAds,
    );
  }
}

/// @nodoc
const $TopItems = _$TopItemsTearOff();

/// @nodoc
mixin _$TopItems {
  Map<String, int> get topQueries => throw _privateConstructorUsedError;
  Map<String, int> get topAds => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TopItemsCopyWith<TopItems> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TopItemsCopyWith<$Res> {
  factory $TopItemsCopyWith(TopItems value, $Res Function(TopItems) then) =
      _$TopItemsCopyWithImpl<$Res>;
  $Res call({Map<String, int> topQueries, Map<String, int> topAds});
}

/// @nodoc
class _$TopItemsCopyWithImpl<$Res> implements $TopItemsCopyWith<$Res> {
  _$TopItemsCopyWithImpl(this._value, this._then);

  final TopItems _value;
  // ignore: unused_field
  final $Res Function(TopItems) _then;

  @override
  $Res call({
    Object? topQueries = freezed,
    Object? topAds = freezed,
  }) {
    return _then(_value.copyWith(
      topQueries: topQueries == freezed
          ? _value.topQueries
          : topQueries // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      topAds: topAds == freezed
          ? _value.topAds
          : topAds // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
    ));
  }
}

/// @nodoc
abstract class _$TopItemsCopyWith<$Res> implements $TopItemsCopyWith<$Res> {
  factory _$TopItemsCopyWith(_TopItems value, $Res Function(_TopItems) then) =
      __$TopItemsCopyWithImpl<$Res>;
  @override
  $Res call({Map<String, int> topQueries, Map<String, int> topAds});
}

/// @nodoc
class __$TopItemsCopyWithImpl<$Res> extends _$TopItemsCopyWithImpl<$Res>
    implements _$TopItemsCopyWith<$Res> {
  __$TopItemsCopyWithImpl(_TopItems _value, $Res Function(_TopItems) _then)
      : super(_value, (v) => _then(v as _TopItems));

  @override
  _TopItems get _value => super._value as _TopItems;

  @override
  $Res call({
    Object? topQueries = freezed,
    Object? topAds = freezed,
  }) {
    return _then(_TopItems(
      topQueries: topQueries == freezed
          ? _value.topQueries
          : topQueries // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      topAds: topAds == freezed
          ? _value.topAds
          : topAds // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
    ));
  }
}

/// @nodoc

class _$_TopItems extends _TopItems {
  _$_TopItems({required this.topQueries, required this.topAds}) : super._();

  @override
  final Map<String, int> topQueries;
  @override
  final Map<String, int> topAds;

  @override
  String toString() {
    return 'TopItems(topQueries: $topQueries, topAds: $topAds)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _TopItems &&
            const DeepCollectionEquality()
                .equals(other.topQueries, topQueries) &&
            const DeepCollectionEquality().equals(other.topAds, topAds));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(topQueries),
      const DeepCollectionEquality().hash(topAds));

  @JsonKey(ignore: true)
  @override
  _$TopItemsCopyWith<_TopItems> get copyWith =>
      __$TopItemsCopyWithImpl<_TopItems>(this, _$identity);
}

abstract class _TopItems extends TopItems {
  factory _TopItems(
      {required Map<String, int> topQueries,
      required Map<String, int> topAds}) = _$_TopItems;
  _TopItems._() : super._();

  @override
  Map<String, int> get topQueries;
  @override
  Map<String, int> get topAds;
  @override
  @JsonKey(ignore: true)
  _$TopItemsCopyWith<_TopItems> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$SleepPiParamsTearOff {
  const _$SleepPiParamsTearOff();

  _SleepPiParams call(PiholeRepositoryParams params, Duration duration) {
    return _SleepPiParams(
      params,
      duration,
    );
  }
}

/// @nodoc
const $SleepPiParams = _$SleepPiParamsTearOff();

/// @nodoc
mixin _$SleepPiParams {
  PiholeRepositoryParams get params => throw _privateConstructorUsedError;
  Duration get duration => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SleepPiParamsCopyWith<SleepPiParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SleepPiParamsCopyWith<$Res> {
  factory $SleepPiParamsCopyWith(
          SleepPiParams value, $Res Function(SleepPiParams) then) =
      _$SleepPiParamsCopyWithImpl<$Res>;
  $Res call({PiholeRepositoryParams params, Duration duration});

  $PiholeRepositoryParamsCopyWith<$Res> get params;
}

/// @nodoc
class _$SleepPiParamsCopyWithImpl<$Res>
    implements $SleepPiParamsCopyWith<$Res> {
  _$SleepPiParamsCopyWithImpl(this._value, this._then);

  final SleepPiParams _value;
  // ignore: unused_field
  final $Res Function(SleepPiParams) _then;

  @override
  $Res call({
    Object? params = freezed,
    Object? duration = freezed,
  }) {
    return _then(_value.copyWith(
      params: params == freezed
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as PiholeRepositoryParams,
      duration: duration == freezed
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
    ));
  }

  @override
  $PiholeRepositoryParamsCopyWith<$Res> get params {
    return $PiholeRepositoryParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value));
    });
  }
}

/// @nodoc
abstract class _$SleepPiParamsCopyWith<$Res>
    implements $SleepPiParamsCopyWith<$Res> {
  factory _$SleepPiParamsCopyWith(
          _SleepPiParams value, $Res Function(_SleepPiParams) then) =
      __$SleepPiParamsCopyWithImpl<$Res>;
  @override
  $Res call({PiholeRepositoryParams params, Duration duration});

  @override
  $PiholeRepositoryParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$SleepPiParamsCopyWithImpl<$Res>
    extends _$SleepPiParamsCopyWithImpl<$Res>
    implements _$SleepPiParamsCopyWith<$Res> {
  __$SleepPiParamsCopyWithImpl(
      _SleepPiParams _value, $Res Function(_SleepPiParams) _then)
      : super(_value, (v) => _then(v as _SleepPiParams));

  @override
  _SleepPiParams get _value => super._value as _SleepPiParams;

  @override
  $Res call({
    Object? params = freezed,
    Object? duration = freezed,
  }) {
    return _then(_SleepPiParams(
      params == freezed
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as PiholeRepositoryParams,
      duration == freezed
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
    ));
  }
}

/// @nodoc

class _$_SleepPiParams implements _SleepPiParams {
  _$_SleepPiParams(this.params, this.duration);

  @override
  final PiholeRepositoryParams params;
  @override
  final Duration duration;

  @override
  String toString() {
    return 'SleepPiParams(params: $params, duration: $duration)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SleepPiParams &&
            (identical(other.params, params) || other.params == params) &&
            (identical(other.duration, duration) ||
                other.duration == duration));
  }

  @override
  int get hashCode => Object.hash(runtimeType, params, duration);

  @JsonKey(ignore: true)
  @override
  _$SleepPiParamsCopyWith<_SleepPiParams> get copyWith =>
      __$SleepPiParamsCopyWithImpl<_SleepPiParams>(this, _$identity);
}

abstract class _SleepPiParams implements SleepPiParams {
  factory _SleepPiParams(PiholeRepositoryParams params, Duration duration) =
      _$_SleepPiParams;

  @override
  PiholeRepositoryParams get params;
  @override
  Duration get duration;
  @override
  @JsonKey(ignore: true)
  _$SleepPiParamsCopyWith<_SleepPiParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiClientNameTearOff {
  const _$PiClientNameTearOff();

  _PiClientName call({required String ip, required String name}) {
    return _PiClientName(
      ip: ip,
      name: name,
    );
  }
}

/// @nodoc
const $PiClientName = _$PiClientNameTearOff();

/// @nodoc
mixin _$PiClientName {
  String get ip => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiClientNameCopyWith<PiClientName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiClientNameCopyWith<$Res> {
  factory $PiClientNameCopyWith(
          PiClientName value, $Res Function(PiClientName) then) =
      _$PiClientNameCopyWithImpl<$Res>;
  $Res call({String ip, String name});
}

/// @nodoc
class _$PiClientNameCopyWithImpl<$Res> implements $PiClientNameCopyWith<$Res> {
  _$PiClientNameCopyWithImpl(this._value, this._then);

  final PiClientName _value;
  // ignore: unused_field
  final $Res Function(PiClientName) _then;

  @override
  $Res call({
    Object? ip = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      ip: ip == freezed
          ? _value.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$PiClientNameCopyWith<$Res>
    implements $PiClientNameCopyWith<$Res> {
  factory _$PiClientNameCopyWith(
          _PiClientName value, $Res Function(_PiClientName) then) =
      __$PiClientNameCopyWithImpl<$Res>;
  @override
  $Res call({String ip, String name});
}

/// @nodoc
class __$PiClientNameCopyWithImpl<$Res> extends _$PiClientNameCopyWithImpl<$Res>
    implements _$PiClientNameCopyWith<$Res> {
  __$PiClientNameCopyWithImpl(
      _PiClientName _value, $Res Function(_PiClientName) _then)
      : super(_value, (v) => _then(v as _PiClientName));

  @override
  _PiClientName get _value => super._value as _PiClientName;

  @override
  $Res call({
    Object? ip = freezed,
    Object? name = freezed,
  }) {
    return _then(_PiClientName(
      ip: ip == freezed
          ? _value.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_PiClientName extends _PiClientName {
  _$_PiClientName({required this.ip, required this.name}) : super._();

  @override
  final String ip;
  @override
  final String name;

  @override
  String toString() {
    return 'PiClientName(ip: $ip, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiClientName &&
            (identical(other.ip, ip) || other.ip == ip) &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(runtimeType, ip, name);

  @JsonKey(ignore: true)
  @override
  _$PiClientNameCopyWith<_PiClientName> get copyWith =>
      __$PiClientNameCopyWithImpl<_PiClientName>(this, _$identity);
}

abstract class _PiClientName extends PiClientName {
  factory _PiClientName({required String ip, required String name}) =
      _$_PiClientName;
  _PiClientName._() : super._();

  @override
  String get ip;
  @override
  String get name;
  @override
  @JsonKey(ignore: true)
  _$PiClientNameCopyWith<_PiClientName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiClientActivityOverTimeTearOff {
  const _$PiClientActivityOverTimeTearOff();

  _PiClientActivityOverTime call(
      {required List<PiClientName> clients,
      required Map<DateTime, List<int>> activity}) {
    return _PiClientActivityOverTime(
      clients: clients,
      activity: activity,
    );
  }
}

/// @nodoc
const $PiClientActivityOverTime = _$PiClientActivityOverTimeTearOff();

/// @nodoc
mixin _$PiClientActivityOverTime {
  List<PiClientName> get clients => throw _privateConstructorUsedError;
  Map<DateTime, List<int>> get activity => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiClientActivityOverTimeCopyWith<PiClientActivityOverTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiClientActivityOverTimeCopyWith<$Res> {
  factory $PiClientActivityOverTimeCopyWith(PiClientActivityOverTime value,
          $Res Function(PiClientActivityOverTime) then) =
      _$PiClientActivityOverTimeCopyWithImpl<$Res>;
  $Res call({List<PiClientName> clients, Map<DateTime, List<int>> activity});
}

/// @nodoc
class _$PiClientActivityOverTimeCopyWithImpl<$Res>
    implements $PiClientActivityOverTimeCopyWith<$Res> {
  _$PiClientActivityOverTimeCopyWithImpl(this._value, this._then);

  final PiClientActivityOverTime _value;
  // ignore: unused_field
  final $Res Function(PiClientActivityOverTime) _then;

  @override
  $Res call({
    Object? clients = freezed,
    Object? activity = freezed,
  }) {
    return _then(_value.copyWith(
      clients: clients == freezed
          ? _value.clients
          : clients // ignore: cast_nullable_to_non_nullable
              as List<PiClientName>,
      activity: activity == freezed
          ? _value.activity
          : activity // ignore: cast_nullable_to_non_nullable
              as Map<DateTime, List<int>>,
    ));
  }
}

/// @nodoc
abstract class _$PiClientActivityOverTimeCopyWith<$Res>
    implements $PiClientActivityOverTimeCopyWith<$Res> {
  factory _$PiClientActivityOverTimeCopyWith(_PiClientActivityOverTime value,
          $Res Function(_PiClientActivityOverTime) then) =
      __$PiClientActivityOverTimeCopyWithImpl<$Res>;
  @override
  $Res call({List<PiClientName> clients, Map<DateTime, List<int>> activity});
}

/// @nodoc
class __$PiClientActivityOverTimeCopyWithImpl<$Res>
    extends _$PiClientActivityOverTimeCopyWithImpl<$Res>
    implements _$PiClientActivityOverTimeCopyWith<$Res> {
  __$PiClientActivityOverTimeCopyWithImpl(_PiClientActivityOverTime _value,
      $Res Function(_PiClientActivityOverTime) _then)
      : super(_value, (v) => _then(v as _PiClientActivityOverTime));

  @override
  _PiClientActivityOverTime get _value =>
      super._value as _PiClientActivityOverTime;

  @override
  $Res call({
    Object? clients = freezed,
    Object? activity = freezed,
  }) {
    return _then(_PiClientActivityOverTime(
      clients: clients == freezed
          ? _value.clients
          : clients // ignore: cast_nullable_to_non_nullable
              as List<PiClientName>,
      activity: activity == freezed
          ? _value.activity
          : activity // ignore: cast_nullable_to_non_nullable
              as Map<DateTime, List<int>>,
    ));
  }
}

/// @nodoc

class _$_PiClientActivityOverTime extends _PiClientActivityOverTime {
  _$_PiClientActivityOverTime({required this.clients, required this.activity})
      : super._();

  @override
  final List<PiClientName> clients;
  @override
  final Map<DateTime, List<int>> activity;

  @override
  String toString() {
    return 'PiClientActivityOverTime(clients: $clients, activity: $activity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiClientActivityOverTime &&
            const DeepCollectionEquality().equals(other.clients, clients) &&
            const DeepCollectionEquality().equals(other.activity, activity));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(clients),
      const DeepCollectionEquality().hash(activity));

  @JsonKey(ignore: true)
  @override
  _$PiClientActivityOverTimeCopyWith<_PiClientActivityOverTime> get copyWith =>
      __$PiClientActivityOverTimeCopyWithImpl<_PiClientActivityOverTime>(
          this, _$identity);
}

abstract class _PiClientActivityOverTime extends PiClientActivityOverTime {
  factory _PiClientActivityOverTime(
          {required List<PiClientName> clients,
          required Map<DateTime, List<int>> activity}) =
      _$_PiClientActivityOverTime;
  _PiClientActivityOverTime._() : super._();

  @override
  List<PiClientName> get clients;
  @override
  Map<DateTime, List<int>> get activity;
  @override
  @JsonKey(ignore: true)
  _$PiClientActivityOverTimeCopyWith<_PiClientActivityOverTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PiVersionsTearOff {
  const _$PiVersionsTearOff();

  _PiVersions call(
      {required bool hasCoreUpdate,
      required bool hasWebUpdate,
      required bool hasFtlUpdate,
      required String currentCoreVersion,
      required String currentWebVersion,
      required String currentFtlVersion,
      required String latestCoreVersion,
      required String latestWebVersion,
      required String latestFtlVersion,
      required String coreBranch,
      required String webBranch,
      required String ftlBranch}) {
    return _PiVersions(
      hasCoreUpdate: hasCoreUpdate,
      hasWebUpdate: hasWebUpdate,
      hasFtlUpdate: hasFtlUpdate,
      currentCoreVersion: currentCoreVersion,
      currentWebVersion: currentWebVersion,
      currentFtlVersion: currentFtlVersion,
      latestCoreVersion: latestCoreVersion,
      latestWebVersion: latestWebVersion,
      latestFtlVersion: latestFtlVersion,
      coreBranch: coreBranch,
      webBranch: webBranch,
      ftlBranch: ftlBranch,
    );
  }
}

/// @nodoc
const $PiVersions = _$PiVersionsTearOff();

/// @nodoc
mixin _$PiVersions {
  bool get hasCoreUpdate => throw _privateConstructorUsedError;
  bool get hasWebUpdate => throw _privateConstructorUsedError;
  bool get hasFtlUpdate => throw _privateConstructorUsedError;
  String get currentCoreVersion => throw _privateConstructorUsedError;
  String get currentWebVersion => throw _privateConstructorUsedError;
  String get currentFtlVersion => throw _privateConstructorUsedError;
  String get latestCoreVersion => throw _privateConstructorUsedError;
  String get latestWebVersion => throw _privateConstructorUsedError;
  String get latestFtlVersion => throw _privateConstructorUsedError;
  String get coreBranch => throw _privateConstructorUsedError;
  String get webBranch => throw _privateConstructorUsedError;
  String get ftlBranch => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PiVersionsCopyWith<PiVersions> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PiVersionsCopyWith<$Res> {
  factory $PiVersionsCopyWith(
          PiVersions value, $Res Function(PiVersions) then) =
      _$PiVersionsCopyWithImpl<$Res>;
  $Res call(
      {bool hasCoreUpdate,
      bool hasWebUpdate,
      bool hasFtlUpdate,
      String currentCoreVersion,
      String currentWebVersion,
      String currentFtlVersion,
      String latestCoreVersion,
      String latestWebVersion,
      String latestFtlVersion,
      String coreBranch,
      String webBranch,
      String ftlBranch});
}

/// @nodoc
class _$PiVersionsCopyWithImpl<$Res> implements $PiVersionsCopyWith<$Res> {
  _$PiVersionsCopyWithImpl(this._value, this._then);

  final PiVersions _value;
  // ignore: unused_field
  final $Res Function(PiVersions) _then;

  @override
  $Res call({
    Object? hasCoreUpdate = freezed,
    Object? hasWebUpdate = freezed,
    Object? hasFtlUpdate = freezed,
    Object? currentCoreVersion = freezed,
    Object? currentWebVersion = freezed,
    Object? currentFtlVersion = freezed,
    Object? latestCoreVersion = freezed,
    Object? latestWebVersion = freezed,
    Object? latestFtlVersion = freezed,
    Object? coreBranch = freezed,
    Object? webBranch = freezed,
    Object? ftlBranch = freezed,
  }) {
    return _then(_value.copyWith(
      hasCoreUpdate: hasCoreUpdate == freezed
          ? _value.hasCoreUpdate
          : hasCoreUpdate // ignore: cast_nullable_to_non_nullable
              as bool,
      hasWebUpdate: hasWebUpdate == freezed
          ? _value.hasWebUpdate
          : hasWebUpdate // ignore: cast_nullable_to_non_nullable
              as bool,
      hasFtlUpdate: hasFtlUpdate == freezed
          ? _value.hasFtlUpdate
          : hasFtlUpdate // ignore: cast_nullable_to_non_nullable
              as bool,
      currentCoreVersion: currentCoreVersion == freezed
          ? _value.currentCoreVersion
          : currentCoreVersion // ignore: cast_nullable_to_non_nullable
              as String,
      currentWebVersion: currentWebVersion == freezed
          ? _value.currentWebVersion
          : currentWebVersion // ignore: cast_nullable_to_non_nullable
              as String,
      currentFtlVersion: currentFtlVersion == freezed
          ? _value.currentFtlVersion
          : currentFtlVersion // ignore: cast_nullable_to_non_nullable
              as String,
      latestCoreVersion: latestCoreVersion == freezed
          ? _value.latestCoreVersion
          : latestCoreVersion // ignore: cast_nullable_to_non_nullable
              as String,
      latestWebVersion: latestWebVersion == freezed
          ? _value.latestWebVersion
          : latestWebVersion // ignore: cast_nullable_to_non_nullable
              as String,
      latestFtlVersion: latestFtlVersion == freezed
          ? _value.latestFtlVersion
          : latestFtlVersion // ignore: cast_nullable_to_non_nullable
              as String,
      coreBranch: coreBranch == freezed
          ? _value.coreBranch
          : coreBranch // ignore: cast_nullable_to_non_nullable
              as String,
      webBranch: webBranch == freezed
          ? _value.webBranch
          : webBranch // ignore: cast_nullable_to_non_nullable
              as String,
      ftlBranch: ftlBranch == freezed
          ? _value.ftlBranch
          : ftlBranch // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$PiVersionsCopyWith<$Res> implements $PiVersionsCopyWith<$Res> {
  factory _$PiVersionsCopyWith(
          _PiVersions value, $Res Function(_PiVersions) then) =
      __$PiVersionsCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool hasCoreUpdate,
      bool hasWebUpdate,
      bool hasFtlUpdate,
      String currentCoreVersion,
      String currentWebVersion,
      String currentFtlVersion,
      String latestCoreVersion,
      String latestWebVersion,
      String latestFtlVersion,
      String coreBranch,
      String webBranch,
      String ftlBranch});
}

/// @nodoc
class __$PiVersionsCopyWithImpl<$Res> extends _$PiVersionsCopyWithImpl<$Res>
    implements _$PiVersionsCopyWith<$Res> {
  __$PiVersionsCopyWithImpl(
      _PiVersions _value, $Res Function(_PiVersions) _then)
      : super(_value, (v) => _then(v as _PiVersions));

  @override
  _PiVersions get _value => super._value as _PiVersions;

  @override
  $Res call({
    Object? hasCoreUpdate = freezed,
    Object? hasWebUpdate = freezed,
    Object? hasFtlUpdate = freezed,
    Object? currentCoreVersion = freezed,
    Object? currentWebVersion = freezed,
    Object? currentFtlVersion = freezed,
    Object? latestCoreVersion = freezed,
    Object? latestWebVersion = freezed,
    Object? latestFtlVersion = freezed,
    Object? coreBranch = freezed,
    Object? webBranch = freezed,
    Object? ftlBranch = freezed,
  }) {
    return _then(_PiVersions(
      hasCoreUpdate: hasCoreUpdate == freezed
          ? _value.hasCoreUpdate
          : hasCoreUpdate // ignore: cast_nullable_to_non_nullable
              as bool,
      hasWebUpdate: hasWebUpdate == freezed
          ? _value.hasWebUpdate
          : hasWebUpdate // ignore: cast_nullable_to_non_nullable
              as bool,
      hasFtlUpdate: hasFtlUpdate == freezed
          ? _value.hasFtlUpdate
          : hasFtlUpdate // ignore: cast_nullable_to_non_nullable
              as bool,
      currentCoreVersion: currentCoreVersion == freezed
          ? _value.currentCoreVersion
          : currentCoreVersion // ignore: cast_nullable_to_non_nullable
              as String,
      currentWebVersion: currentWebVersion == freezed
          ? _value.currentWebVersion
          : currentWebVersion // ignore: cast_nullable_to_non_nullable
              as String,
      currentFtlVersion: currentFtlVersion == freezed
          ? _value.currentFtlVersion
          : currentFtlVersion // ignore: cast_nullable_to_non_nullable
              as String,
      latestCoreVersion: latestCoreVersion == freezed
          ? _value.latestCoreVersion
          : latestCoreVersion // ignore: cast_nullable_to_non_nullable
              as String,
      latestWebVersion: latestWebVersion == freezed
          ? _value.latestWebVersion
          : latestWebVersion // ignore: cast_nullable_to_non_nullable
              as String,
      latestFtlVersion: latestFtlVersion == freezed
          ? _value.latestFtlVersion
          : latestFtlVersion // ignore: cast_nullable_to_non_nullable
              as String,
      coreBranch: coreBranch == freezed
          ? _value.coreBranch
          : coreBranch // ignore: cast_nullable_to_non_nullable
              as String,
      webBranch: webBranch == freezed
          ? _value.webBranch
          : webBranch // ignore: cast_nullable_to_non_nullable
              as String,
      ftlBranch: ftlBranch == freezed
          ? _value.ftlBranch
          : ftlBranch // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_PiVersions extends _PiVersions {
  _$_PiVersions(
      {required this.hasCoreUpdate,
      required this.hasWebUpdate,
      required this.hasFtlUpdate,
      required this.currentCoreVersion,
      required this.currentWebVersion,
      required this.currentFtlVersion,
      required this.latestCoreVersion,
      required this.latestWebVersion,
      required this.latestFtlVersion,
      required this.coreBranch,
      required this.webBranch,
      required this.ftlBranch})
      : super._();

  @override
  final bool hasCoreUpdate;
  @override
  final bool hasWebUpdate;
  @override
  final bool hasFtlUpdate;
  @override
  final String currentCoreVersion;
  @override
  final String currentWebVersion;
  @override
  final String currentFtlVersion;
  @override
  final String latestCoreVersion;
  @override
  final String latestWebVersion;
  @override
  final String latestFtlVersion;
  @override
  final String coreBranch;
  @override
  final String webBranch;
  @override
  final String ftlBranch;

  @override
  String toString() {
    return 'PiVersions(hasCoreUpdate: $hasCoreUpdate, hasWebUpdate: $hasWebUpdate, hasFtlUpdate: $hasFtlUpdate, currentCoreVersion: $currentCoreVersion, currentWebVersion: $currentWebVersion, currentFtlVersion: $currentFtlVersion, latestCoreVersion: $latestCoreVersion, latestWebVersion: $latestWebVersion, latestFtlVersion: $latestFtlVersion, coreBranch: $coreBranch, webBranch: $webBranch, ftlBranch: $ftlBranch)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PiVersions &&
            (identical(other.hasCoreUpdate, hasCoreUpdate) ||
                other.hasCoreUpdate == hasCoreUpdate) &&
            (identical(other.hasWebUpdate, hasWebUpdate) ||
                other.hasWebUpdate == hasWebUpdate) &&
            (identical(other.hasFtlUpdate, hasFtlUpdate) ||
                other.hasFtlUpdate == hasFtlUpdate) &&
            (identical(other.currentCoreVersion, currentCoreVersion) ||
                other.currentCoreVersion == currentCoreVersion) &&
            (identical(other.currentWebVersion, currentWebVersion) ||
                other.currentWebVersion == currentWebVersion) &&
            (identical(other.currentFtlVersion, currentFtlVersion) ||
                other.currentFtlVersion == currentFtlVersion) &&
            (identical(other.latestCoreVersion, latestCoreVersion) ||
                other.latestCoreVersion == latestCoreVersion) &&
            (identical(other.latestWebVersion, latestWebVersion) ||
                other.latestWebVersion == latestWebVersion) &&
            (identical(other.latestFtlVersion, latestFtlVersion) ||
                other.latestFtlVersion == latestFtlVersion) &&
            (identical(other.coreBranch, coreBranch) ||
                other.coreBranch == coreBranch) &&
            (identical(other.webBranch, webBranch) ||
                other.webBranch == webBranch) &&
            (identical(other.ftlBranch, ftlBranch) ||
                other.ftlBranch == ftlBranch));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      hasCoreUpdate,
      hasWebUpdate,
      hasFtlUpdate,
      currentCoreVersion,
      currentWebVersion,
      currentFtlVersion,
      latestCoreVersion,
      latestWebVersion,
      latestFtlVersion,
      coreBranch,
      webBranch,
      ftlBranch);

  @JsonKey(ignore: true)
  @override
  _$PiVersionsCopyWith<_PiVersions> get copyWith =>
      __$PiVersionsCopyWithImpl<_PiVersions>(this, _$identity);
}

abstract class _PiVersions extends PiVersions {
  factory _PiVersions(
      {required bool hasCoreUpdate,
      required bool hasWebUpdate,
      required bool hasFtlUpdate,
      required String currentCoreVersion,
      required String currentWebVersion,
      required String currentFtlVersion,
      required String latestCoreVersion,
      required String latestWebVersion,
      required String latestFtlVersion,
      required String coreBranch,
      required String webBranch,
      required String ftlBranch}) = _$_PiVersions;
  _PiVersions._() : super._();

  @override
  bool get hasCoreUpdate;
  @override
  bool get hasWebUpdate;
  @override
  bool get hasFtlUpdate;
  @override
  String get currentCoreVersion;
  @override
  String get currentWebVersion;
  @override
  String get currentFtlVersion;
  @override
  String get latestCoreVersion;
  @override
  String get latestWebVersion;
  @override
  String get latestFtlVersion;
  @override
  String get coreBranch;
  @override
  String get webBranch;
  @override
  String get ftlBranch;
  @override
  @JsonKey(ignore: true)
  _$PiVersionsCopyWith<_PiVersions> get copyWith =>
      throw _privateConstructorUsedError;
}
